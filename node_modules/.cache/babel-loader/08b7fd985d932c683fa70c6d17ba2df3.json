{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar assert = require(\"assert\");\n\nvar comments = require(\"./comments\");\n\nvar FastPath = require(\"../common/fast-path\");\n\nvar multiparser = require(\"./multiparser\");\n\nvar doc = require(\"../doc\");\n\nvar docBuilders = doc.builders;\nvar concat = docBuilders.concat;\nvar hardline = docBuilders.hardline;\nvar addAlignmentToDoc = docBuilders.addAlignmentToDoc;\nvar docUtils = doc.utils;\n/**\n * Takes an abstract syntax tree (AST) and recursively converts it to a\n * document (series of printing primitives).\n *\n * This is done by descending down the AST recursively. The recursion\n * involves two functions that call each other:\n *\n * 1. printGenerically(), which is defined as an inner function here.\n *    It basically takes care of node caching.\n * 2. callPluginPrintFunction(), which checks for some options, and\n *    ultimately calls the print() function provided by the plugin.\n *\n * The plugin function will call printGenerically() again for child nodes\n * of the current node, which will do its housekeeping, then call the\n * plugin function again, and so on.\n *\n * All the while, these functions pass a \"path\" variable around, which\n * is a stack-like data structure (FastPath) that maintains the current\n * state of the recursion. It is called \"path\", because it represents\n * the path to the current node through the Abstract Syntax Tree.\n */\n\nfunction printAstToDoc(ast, options) {\n  var alignmentSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var printer = options.printer;\n\n  if (printer.preprocess) {\n    ast = printer.preprocess(ast, options);\n  }\n\n  var cache = new Map();\n\n  function printGenerically(path, args) {\n    var node = path.getValue();\n    var shouldCache = node && _typeof(node) === \"object\" && args === undefined;\n\n    if (shouldCache && cache.has(node)) {\n      return cache.get(node);\n    } // We let JSXElement print its comments itself because it adds () around\n    // UnionTypeAnnotation has to align the child without the comments\n\n\n    var res;\n\n    if (printer.willPrintOwnComments && printer.willPrintOwnComments(path, options)) {\n      res = callPluginPrintFunction(path, options, printGenerically, args);\n    } else {\n      // printComments will call the plugin print function and check for\n      // comments to print\n      res = comments.printComments(path, function (p) {\n        return callPluginPrintFunction(p, options, printGenerically, args);\n      }, options, args && args.needsSemi);\n    }\n\n    if (shouldCache) {\n      cache.set(node, res);\n    }\n\n    return res;\n  }\n\n  var doc = printGenerically(new FastPath(ast));\n\n  if (alignmentSize > 0) {\n    // Add a hardline to make the indents take effect\n    // It should be removed in index.js format()\n    doc = addAlignmentToDoc(concat([hardline, doc]), alignmentSize, options.tabWidth);\n  }\n\n  docUtils.propagateBreaks(doc);\n  return doc;\n}\n\nfunction callPluginPrintFunction(path, options, printPath, args) {\n  assert.ok(path instanceof FastPath);\n  var node = path.getValue();\n  var printer = options.printer; // Escape hatch\n\n  if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {\n    return options.originalText.slice(options.locStart(node), options.locEnd(node));\n  }\n\n  if (node) {\n    try {\n      // Potentially switch to a different parser\n      var sub = multiparser.printSubtree(path, printPath, options, printAstToDoc);\n\n      if (sub) {\n        return sub;\n      }\n    } catch (error) {\n      /* istanbul ignore if */\n      if (process.env.PRETTIER_DEBUG) {\n        throw error;\n      } // Continue with current parser\n\n    }\n  }\n\n  return printer.print(path, options, printPath, args);\n}\n\nmodule.exports = printAstToDoc;","map":null,"metadata":{},"sourceType":"script"}