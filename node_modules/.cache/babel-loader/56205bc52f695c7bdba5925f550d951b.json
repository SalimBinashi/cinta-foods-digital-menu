{"ast":null,"code":"import _defineProperty from \"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/*\nCopyright (c) 2020 Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\nimport { useState, useReducer, useEffect } from 'react';\nimport copy from 'copy-to-clipboard';\nimport debounce from 'lodash/debounce'; // transformations, code generation\n\nimport { transformBeforeCompilation } from './ast';\nimport { getCode, formatCode as _formatCode } from './code-generator';\nimport { buildPropsObj } from './utils'; // actions that can be dispatched\n\nimport { reset as _reset, updateAll, updateCode, updateCodeAndProvider, updateProps, updatePropsAndCode, updatePropsAndCodeNoRecompile } from './actions';\nimport reducer from './reducer';\n\nvar useView = function useView() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // setting defaults\n  var componentName = config.componentName ? config.componentName : '';\n  var propsConfig = config.props ? config.props : {};\n  var scopeConfig = config.scope ? config.scope : {};\n  var importsConfig = config.imports ? config.imports : {};\n  var provider = config.provider ? config.provider : {\n    value: undefined,\n    parse: function parse() {\n      return undefined;\n    },\n    generate: function generate(_, child) {\n      return child;\n    },\n    imports: {}\n  };\n  var onUpdate = config.onUpdate ? config.onUpdate : function () {};\n  var customProps = config.customProps ? config.customProps : {};\n  var initialCode = config.initialCode;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      hydrated = _useState2[0],\n      setHydrated = _useState2[1];\n\n  var _useState3 = useState({\n    where: '',\n    msg: null\n  }),\n      _useState4 = _slicedToArray(_useState3, 2),\n      error = _useState4[0],\n      _setError = _useState4[1];\n\n  var _useReducer = useReducer(reducer, {\n    code: initialCode || getCode({\n      props: propsConfig,\n      componentName: componentName,\n      provider: provider,\n      providerValue: provider.value,\n      importsConfig: importsConfig,\n      customProps: customProps\n    }),\n    codeNoRecompile: '',\n    props: propsConfig,\n    providerValue: provider ? provider.value : undefined\n  }),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      state = _useReducer2[0],\n      dispatch = _useReducer2[1]; // initialize from the initialCode\n\n\n  useEffect(function () {\n    if (initialCode && !hydrated) {\n      setHydrated(true);\n\n      try {\n        updateAll(dispatch, initialCode, componentName, propsConfig, provider ? provider.parse : undefined, customProps);\n      } catch (e) {}\n    }\n  }, [initialCode]); // this callback is secretely inserted into props marked with\n  // \"propHook\" this way we can get notified when the internal\n  // state of previewed component is changed by user\n\n  var __reactViewOnChange = debounce(function (propValue, propName) {\n    !hydrated && setHydrated(true);\n    var newCode = getCode({\n      props: buildPropsObj(state.props, _defineProperty({}, propName, propValue)),\n      componentName: componentName,\n      provider: provider,\n      providerValue: state.providerValue,\n      importsConfig: importsConfig,\n      customProps: customProps\n    });\n    updatePropsAndCodeNoRecompile(dispatch, newCode, propName, propValue);\n    onUpdate({\n      code: newCode\n    });\n  }, 200);\n\n  return {\n    compilerProps: {\n      code: state.code,\n      setError: function setError(msg) {\n        return _setError({\n          where: '__compiler',\n          msg: msg\n        });\n      },\n      transformations: [function (ast) {\n        return transformBeforeCompilation(ast, componentName, propsConfig);\n      }],\n      scope: Object.assign(Object.assign({}, scopeConfig), {\n        __reactViewOnChange: __reactViewOnChange\n      })\n    },\n    knobProps: {\n      state: state.props,\n      error: error,\n      set: function set(propValue, propName) {\n        try {\n          !hydrated && setHydrated(true);\n          var newCode = getCode({\n            props: buildPropsObj(state.props, _defineProperty({}, propName, propValue)),\n            componentName: componentName,\n            provider: provider,\n            providerValue: state.providerValue,\n            importsConfig: importsConfig,\n            customProps: customProps\n          });\n\n          _setError({\n            where: '',\n            msg: null\n          });\n\n          if (state.codeNoRecompile !== '') {\n            // fixes https://github.com/uber/react-view/issues/19\n            // We don't run compiler when the state change comes from interacting\n            // with the component since that causes remount and lost of focus.\n            // That's a bad experience for interactions like typing. But, we\n            // still want to display correct code snippet. That's why we have\n            // a separate state.codeNoRecompile. The problem is that compiler runs\n            // only if state.code changes and that doesn't really happen in the modal\n            // case since we are only flipping a boolean flag. So state.code stays same\n            // each even cycle of \"open the modal through the knob and close it by its button\".\n            // so here we need to force an addition state.code update (aka recompile\n            // with show=false\n            updateCode(dispatch, state.codeNoRecompile); // and now we need to do the sequential state.code update with show=true\n            // in the next tick\n\n            setTimeout(function () {\n              updatePropsAndCode(dispatch, newCode, propName, propValue);\n              onUpdate({\n                code: newCode\n              });\n            }, 0);\n          } else {\n            updatePropsAndCode(dispatch, newCode, propName, propValue);\n            onUpdate({\n              code: newCode\n            });\n          }\n        } catch (e) {\n          updateProps(dispatch, propName, propValue);\n\n          _setError({\n            where: propName,\n            msg: e.toString()\n          });\n        }\n      }\n    },\n    providerValue: state.providerValue,\n    editorProps: {\n      code: state.codeNoRecompile !== '' ? state.codeNoRecompile : state.code,\n      onChange: function onChange(newCode) {\n        try {\n          updateAll(dispatch, newCode, componentName, propsConfig, provider ? provider.parse : undefined, customProps);\n          onUpdate({\n            code: newCode\n          });\n        } catch (e) {\n          updateCode(dispatch, newCode);\n        }\n      }\n    },\n    errorProps: {\n      msg: error.where === '__compiler' ? error.msg : null,\n      code: state.code\n    },\n    actions: {\n      formatCode: function formatCode() {\n        updateCode(dispatch, _formatCode(state.code));\n      },\n      copyCode: function copyCode() {\n        copy(state.code);\n      },\n      copyUrl: function copyUrl() {\n        copy(window.location.href);\n      },\n      reset: function reset() {\n        var editorOnlyMode = Object.keys(propsConfig).length === 0;\n        var providerValue = provider ? provider.value : undefined;\n        var newCode = editorOnlyMode ? initialCode : getCode({\n          props: propsConfig,\n          componentName: componentName,\n          provider: provider,\n          providerValue: providerValue,\n          importsConfig: importsConfig,\n          customProps: customProps\n        });\n\n        _reset(dispatch, newCode, providerValue, propsConfig);\n\n        onUpdate({\n          code: newCode\n        });\n      },\n      updateProvider: function updateProvider(providerValue) {\n        var newCode = getCode({\n          props: buildPropsObj(state.props, {}),\n          componentName: componentName,\n          provider: provider,\n          providerValue: providerValue,\n          importsConfig: importsConfig,\n          customProps: customProps\n        });\n        updateCodeAndProvider(dispatch, newCode, providerValue);\n      },\n      updateProp: function updateProp(propName, propValue) {\n        try {\n          var newCode = getCode({\n            props: buildPropsObj(state.props, _defineProperty({}, propName, propValue)),\n            componentName: componentName,\n            provider: provider,\n            providerValue: state.providerValue,\n            importsConfig: importsConfig,\n            customProps: customProps\n          });\n\n          _setError({\n            where: '',\n            msg: null\n          });\n\n          updatePropsAndCode(dispatch, newCode, propName, propValue);\n        } catch (e) {\n          updateProps(dispatch, propName, propValue);\n\n          _setError({\n            where: propName,\n            msg: e.toString()\n          });\n        }\n      }\n    }\n  };\n};\n\nexport default useView;","map":null,"metadata":{},"sourceType":"module"}