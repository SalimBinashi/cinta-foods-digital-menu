{"ast":null,"code":"\"use strict\"; // This file is currently named parser-babylon.js to maintain backwards compatibility.\n// However, it should be named parser-babel.js in the next major release.\n\nvar createError = require(\"../common/parser-create-error\");\n\nvar hasPragma = require(\"./pragma\").hasPragma;\n\nvar locFns = require(\"./loc\");\n\nvar postprocess = require(\"./postprocess\");\n\nvar babelParser = require(\"@babel/parser\");\n\nfunction babelOptions(extraOptions, extraPlugins) {\n  return Object.assign({\n    sourceType: \"module\",\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    plugins: [\"jsx\", \"doExpressions\", \"objectRestSpread\", \"classProperties\", \"exportDefaultFrom\", \"exportNamespaceFrom\", \"asyncGenerators\", \"functionBind\", \"functionSent\", \"dynamicImport\", \"numericSeparator\", \"importMeta\", \"optionalCatchBinding\", \"optionalChaining\", \"classPrivateProperties\", [\"pipelineOperator\", {\n      proposal: \"minimal\"\n    }], \"nullishCoalescingOperator\", \"bigInt\", \"throwExpressions\", \"logicalAssignment\", \"classPrivateMethods\"].concat(extraPlugins)\n  }, extraOptions);\n}\n\nfunction createParse(parseMethod, extraPlugins) {\n  return function (text, parsers, opts) {\n    // Inline the require to avoid loading all the JS if we don't use it\n    var combinations = [babelOptions({\n      strictMode: true\n    }, [\"decorators-legacy\"].concat(extraPlugins)), babelOptions({\n      strictMode: false\n    }, [\"decorators-legacy\"].concat(extraPlugins)), babelOptions({\n      strictMode: true\n    }, [[\"decorators\", {\n      decoratorsBeforeExport: false\n    }]].concat(extraPlugins)), babelOptions({\n      strictMode: false\n    }, [[\"decorators\", {\n      decoratorsBeforeExport: false\n    }]].concat(extraPlugins))];\n    var ast;\n\n    try {\n      ast = tryCombinations(babelParser[parseMethod].bind(null, text), combinations);\n    } catch (error) {\n      throw createError( // babel error prints (l:c) with cols that are zero indexed\n      // so we need our custom error\n      error.message.replace(/ \\(.*\\)/, \"\"), {\n        start: {\n          line: error.loc.line,\n          column: error.loc.column + 1\n        }\n      });\n    }\n\n    delete ast.tokens;\n    return postprocess(ast, Object.assign({}, opts, {\n      originalText: text\n    }));\n  };\n}\n\nvar parse = createParse(\"parse\", [\"flow\"]);\nvar parseFlow = createParse(\"parse\", [[\"flow\", {\n  all: true\n}]]);\nvar parseExpression = createParse(\"parseExpression\");\n\nfunction tryCombinations(fn, combinations) {\n  var error;\n\n  for (var i = 0; i < combinations.length; i++) {\n    try {\n      return fn(combinations[i]);\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n\n  throw error;\n}\n\nfunction parseJson(text, parsers, opts) {\n  var ast = parseExpression(text, parsers, opts);\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n\n    case \"ObjectProperty\":\n      // istanbul ignore if\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      } // istanbul ignore if\n\n\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n\n      return [node.key, node.value].forEach(assertJsonChildNode);\n\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        // istanbul ignore next\n\n        default:\n          throw createJsonError(\"operator\");\n      }\n\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n\n      throw createJsonError();\n\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    // istanbul ignore next\n\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  } // istanbul ignore next\n\n\n  function createJsonError(attribute) {\n    var name = !attribute ? node.type : \"\".concat(node.type, \" with \").concat(attribute, \"=\").concat(JSON.stringify(node[attribute]));\n    return createError(\"\".concat(name, \" is not allowed in JSON.\"), {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1\n      }\n    });\n  }\n}\n\nvar babel = Object.assign({\n  parse: parse,\n  astFormat: \"estree\",\n  hasPragma: hasPragma\n}, locFns);\nvar babelFlow = Object.assign({}, babel, {\n  parse: parseFlow\n});\nvar babelExpression = Object.assign({}, babel, {\n  parse: parseExpression\n}); // Export as a plugin so we can reuse the same bundle for UMD loading\n\nmodule.exports = {\n  parsers: {\n    babel: babel,\n    \"babel-flow\": babelFlow,\n    // aliased to keep backwards compatibility\n    babylon: babel,\n    json: Object.assign({}, babelExpression, {\n      hasPragma: function hasPragma() {\n        return true;\n      }\n    }),\n    json5: babelExpression,\n    \"json-stringify\": Object.assign({\n      parse: parseJson,\n      astFormat: \"estree-json\"\n    }, locFns),\n\n    /** @internal */\n    __js_expression: babelExpression,\n\n    /** for vue filter */\n    __vue_expression: babelExpression,\n\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel\n  }\n};","map":null,"metadata":{},"sourceType":"script"}