{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar _require = require(\"./comments\"),\n    isBlockComment = _require.isBlockComment,\n    hasLeadingComment = _require.hasLeadingComment;\n\nvar _require2 = require(\"../doc\"),\n    _require2$builders = _require2.builders,\n    indent = _require2$builders.indent,\n    join = _require2$builders.join,\n    hardline = _require2$builders.hardline,\n    softline = _require2$builders.softline,\n    literalline = _require2$builders.literalline,\n    concat = _require2$builders.concat,\n    group = _require2$builders.group,\n    dedentToRoot = _require2$builders.dedentToRoot,\n    _require2$utils = _require2.utils,\n    mapDoc = _require2$utils.mapDoc,\n    stripTrailingHardline = _require2$utils.stripTrailingHardline;\n\nfunction embed(path, print, textToDoc, options) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n\n  switch (node.type) {\n    case \"TemplateLiteral\":\n      {\n        var isCss = [isStyledJsx, isStyledComponents, isCssProp, isAngularComponentStyles].some(function (isIt) {\n          return isIt(path);\n        });\n\n        if (isCss) {\n          // Get full template literal with expressions replaced by placeholders\n          var rawQuasis = node.quasis.map(function (q) {\n            return q.value.raw;\n          });\n          var placeholderID = 0;\n          var text = rawQuasis.reduce(function (prevVal, currVal, idx) {\n            return idx == 0 ? currVal : prevVal + \"@prettier-placeholder-\" + placeholderID++ + \"-id\" + currVal;\n          }, \"\");\n          var doc = textToDoc(text, {\n            parser: \"css\"\n          });\n          return transformCssDoc(doc, path, print);\n        }\n        /*\n         * react-relay and graphql-tag\n         * graphql`...`\n         * graphql.experimental`...`\n         * gql`...`\n         *\n         * This intentionally excludes Relay Classic tags, as Prettier does not\n         * support Relay Classic formatting.\n         */\n\n\n        if (isGraphQL(path)) {\n          var expressionDocs = node.expressions ? path.map(print, \"expressions\") : [];\n          var numQuasis = node.quasis.length;\n\n          if (numQuasis === 1 && node.quasis[0].value.raw.trim() === \"\") {\n            return \"``\";\n          }\n\n          var parts = [];\n\n          for (var i = 0; i < numQuasis; i++) {\n            var templateElement = node.quasis[i];\n            var isFirst = i === 0;\n            var isLast = i === numQuasis - 1;\n            var _text = templateElement.value.cooked; // Bail out if any of the quasis have an invalid escape sequence\n            // (which would make the `cooked` value be `null` or `undefined`)\n\n            if (typeof _text !== \"string\") {\n              return null;\n            }\n\n            var lines = _text.split(\"\\n\");\n\n            var numLines = lines.length;\n            var expressionDoc = expressionDocs[i];\n            var startsWithBlankLine = numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";\n            var endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === \"\" && lines[numLines - 2].trim() === \"\";\n            var commentsAndWhitespaceOnly = lines.every(function (line) {\n              return /^\\s*(?:#[^\\r\\n]*)?$/.test(line);\n            }); // Bail out if an interpolation occurs within a comment.\n\n            if (!isLast && /#[^\\r\\n]*$/.test(lines[numLines - 1])) {\n              return null;\n            }\n\n            var _doc = null;\n\n            if (commentsAndWhitespaceOnly) {\n              _doc = printGraphqlComments(lines);\n            } else {\n              _doc = stripTrailingHardline(textToDoc(_text, {\n                parser: \"graphql\"\n              }));\n            }\n\n            if (_doc) {\n              _doc = escapeTemplateCharacters(_doc, false);\n\n              if (!isFirst && startsWithBlankLine) {\n                parts.push(\"\");\n              }\n\n              parts.push(_doc);\n\n              if (!isLast && endsWithBlankLine) {\n                parts.push(\"\");\n              }\n            } else if (!isFirst && !isLast && startsWithBlankLine) {\n              parts.push(\"\");\n            }\n\n            if (expressionDoc) {\n              parts.push(concat([\"${\", expressionDoc, \"}\"]));\n            }\n          }\n\n          return concat([\"`\", indent(concat([hardline, join(hardline, parts)])), hardline, \"`\"]);\n        }\n\n        var htmlParser = isHtml(path) ? \"html\" : isAngularComponentTemplate(path) ? \"angular\" : undefined;\n\n        if (htmlParser) {\n          return printHtmlTemplateLiteral(path, print, textToDoc, htmlParser, options.embeddedInHtml);\n        }\n\n        break;\n      }\n\n    case \"TemplateElement\":\n      {\n        /**\n         * md`...`\n         * markdown`...`\n         */\n        if (parentParent && parentParent.type === \"TaggedTemplateExpression\" && parent.quasis.length === 1 && parentParent.tag.type === \"Identifier\" && (parentParent.tag.name === \"md\" || parentParent.tag.name === \"markdown\")) {\n          var _text2 = parent.quasis[0].value.raw.replace(/((?:\\\\\\\\)*)\\\\`/g, function (_, backslashes) {\n            return \"\\\\\".repeat(backslashes.length / 2) + \"`\";\n          });\n\n          var indentation = getIndentation(_text2);\n          var hasIndent = indentation !== \"\";\n          return concat([hasIndent ? indent(concat([softline, printMarkdown(_text2.replace(new RegExp(\"^\".concat(indentation), \"gm\"), \"\"))])) : concat([literalline, dedentToRoot(printMarkdown(_text2))]), softline]);\n        }\n\n        break;\n      }\n  }\n\n  function printMarkdown(text) {\n    var doc = textToDoc(text, {\n      parser: \"markdown\",\n      __inJsTemplate: true\n    });\n    return stripTrailingHardline(escapeTemplateCharacters(doc, true));\n  }\n}\n\nfunction getIndentation(str) {\n  var firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);\n  return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];\n}\n\nfunction uncook(cookedValue) {\n  return cookedValue.replace(/([\\\\`]|\\$\\{)/g, \"\\\\$1\");\n}\n\nfunction escapeTemplateCharacters(doc, raw) {\n  return mapDoc(doc, function (currentDoc) {\n    if (!currentDoc.parts) {\n      return currentDoc;\n    }\n\n    var parts = [];\n    currentDoc.parts.forEach(function (part) {\n      if (typeof part === \"string\") {\n        parts.push(raw ? part.replace(/(\\\\*)`/g, \"$1$1\\\\`\") : uncook(part));\n      } else {\n        parts.push(part);\n      }\n    });\n    return Object.assign({}, currentDoc, {\n      parts: parts\n    });\n  });\n}\n\nfunction transformCssDoc(quasisDoc, path, print) {\n  var parentNode = path.getValue();\n  var isEmpty = parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();\n\n  if (isEmpty) {\n    return \"``\";\n  }\n\n  var expressionDocs = parentNode.expressions ? path.map(print, \"expressions\") : [];\n  var newDoc = replacePlaceholders(quasisDoc, expressionDocs);\n  /* istanbul ignore if */\n\n  if (!newDoc) {\n    throw new Error(\"Couldn't insert all the expressions\");\n  }\n\n  return concat([\"`\", indent(concat([hardline, stripTrailingHardline(newDoc)])), softline, \"`\"]);\n} // Search all the placeholders in the quasisDoc tree\n// and replace them with the expression docs one by one\n// returns a new doc with all the placeholders replaced,\n// or null if it couldn't replace any expression\n\n\nfunction replacePlaceholders(quasisDoc, expressionDocs) {\n  if (!expressionDocs || !expressionDocs.length) {\n    return quasisDoc;\n  }\n\n  var expressions = expressionDocs.slice();\n  var replaceCounter = 0;\n  var newDoc = mapDoc(quasisDoc, function (doc) {\n    if (!doc || !doc.parts || !doc.parts.length) {\n      return doc;\n    }\n\n    var parts = doc.parts;\n    var atIndex = parts.indexOf(\"@\");\n    var placeholderIndex = atIndex + 1;\n\n    if (atIndex > -1 && typeof parts[placeholderIndex] === \"string\" && parts[placeholderIndex].startsWith(\"prettier-placeholder\")) {\n      // If placeholder is split, join it\n      var at = parts[atIndex];\n      var placeholder = parts[placeholderIndex];\n      var rest = parts.slice(placeholderIndex + 1);\n      parts = parts.slice(0, atIndex).concat([at + placeholder]).concat(rest);\n    }\n\n    var atPlaceholderIndex = parts.findIndex(function (part) {\n      return typeof part === \"string\" && part.startsWith(\"@prettier-placeholder\");\n    });\n\n    if (atPlaceholderIndex > -1) {\n      var _placeholder = parts[atPlaceholderIndex];\n\n      var _rest = parts.slice(atPlaceholderIndex + 1);\n\n      var placeholderMatch = _placeholder.match(/@prettier-placeholder-(.+)-id([\\s\\S]*)/);\n\n      var placeholderID = placeholderMatch[1]; // When the expression has a suffix appended, like:\n      // animation: linear ${time}s ease-out;\n\n      var suffix = placeholderMatch[2];\n      var expression = expressions[placeholderID];\n      replaceCounter++;\n      parts = parts.slice(0, atPlaceholderIndex).concat([\"${\", expression, \"}\" + suffix]).concat(_rest);\n    }\n\n    return Object.assign({}, doc, {\n      parts: parts\n    });\n  });\n  return expressions.length === replaceCounter ? newDoc : null;\n}\n\nfunction printGraphqlComments(lines) {\n  var parts = [];\n  var seenComment = false;\n  lines.map(function (textLine) {\n    return textLine.trim();\n  }).forEach(function (textLine, i, array) {\n    // Lines are either whitespace only, or a comment (with poential whitespace\n    // around it). Drop whitespace-only lines.\n    if (textLine === \"\") {\n      return;\n    }\n\n    if (array[i - 1] === \"\" && seenComment) {\n      // If a non-first comment is preceded by a blank (whitespace only) line,\n      // add in a blank line.\n      parts.push(concat([hardline, textLine]));\n    } else {\n      parts.push(textLine);\n    }\n\n    seenComment = true;\n  }); // If `lines` was whitespace only, return `null`.\n\n  return parts.length === 0 ? null : join(hardline, parts);\n}\n/**\n * Template literal in these contexts:\n * <style jsx>{`div{color:red}`}</style>\n * css``\n * css.global``\n * css.resolve``\n */\n\n\nfunction isStyledJsx(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n  return parentParent && node.quasis && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXElement\" && parentParent.openingElement.name.name === \"style\" && parentParent.openingElement.attributes.some(function (attribute) {\n    return attribute.name.name === \"jsx\";\n  }) || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"Identifier\" && parent.tag.name === \"css\" || parent && parent.type === \"TaggedTemplateExpression\" && parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"css\" && (parent.tag.property.name === \"global\" || parent.tag.property.name === \"resolve\");\n}\n/**\n * Angular Components can have:\n * - Inline HTML template\n * - Inline CSS styles\n *\n * ...which are both within template literals somewhere\n * inside of the Component decorator factory.\n *\n * E.g.\n * @Component({\n *  template: `<div>...</div>`,\n *  styles: [`h1 { color: blue; }`]\n * })\n */\n\n\nfunction isAngularComponentStyles(path) {\n  return isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"ArrayExpression\" && name === \"elements\";\n  }, function (node, name) {\n    return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"styles\" && name === \"value\";\n  }].concat(getAngularComponentObjectExpressionPredicates()));\n}\n\nfunction isAngularComponentTemplate(path) {\n  return isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"Property\" && node.key.type === \"Identifier\" && node.key.name === \"template\" && name === \"value\";\n  }].concat(getAngularComponentObjectExpressionPredicates()));\n}\n\nfunction getAngularComponentObjectExpressionPredicates() {\n  return [function (node, name) {\n    return node.type === \"ObjectExpression\" && name === \"properties\";\n  }, function (node, name) {\n    return node.type === \"CallExpression\" && node.callee.type === \"Identifier\" && node.callee.name === \"Component\" && name === \"arguments\";\n  }, function (node, name) {\n    return node.type === \"Decorator\" && name === \"expression\";\n  }];\n}\n/**\n * styled-components template literals\n */\n\n\nfunction isStyledComponents(path) {\n  var parent = path.getParentNode();\n\n  if (!parent || parent.type !== \"TaggedTemplateExpression\") {\n    return false;\n  }\n\n  var tag = parent.tag;\n\n  switch (tag.type) {\n    case \"MemberExpression\":\n      return (// styled.foo``\n        isStyledIdentifier(tag.object) || // Component.extend``\n        isStyledExtend(tag)\n      );\n\n    case \"CallExpression\":\n      return (// styled(Component)``\n        isStyledIdentifier(tag.callee) || tag.callee.type === \"MemberExpression\" && (tag.callee.object.type === \"MemberExpression\" && ( // styled.foo.attrs({})``\n        isStyledIdentifier(tag.callee.object.object) || // Component.extend.attrs({})``\n        isStyledExtend(tag.callee.object)) || // styled(Component).attrs({})``\n        tag.callee.object.type === \"CallExpression\" && isStyledIdentifier(tag.callee.object.callee))\n      );\n\n    case \"Identifier\":\n      // css``\n      return tag.name === \"css\";\n\n    default:\n      return false;\n  }\n}\n/**\n * JSX element with CSS prop\n */\n\n\nfunction isCssProp(path) {\n  var parent = path.getParentNode();\n  var parentParent = path.getParentNode(1);\n  return parentParent && parent.type === \"JSXExpressionContainer\" && parentParent.type === \"JSXAttribute\" && parentParent.name.type === \"JSXIdentifier\" && parentParent.name.name === \"css\";\n}\n\nfunction isStyledIdentifier(node) {\n  return node.type === \"Identifier\" && node.name === \"styled\";\n}\n\nfunction isStyledExtend(node) {\n  return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";\n}\n/*\n * react-relay and graphql-tag\n * graphql`...`\n * graphql.experimental`...`\n * gql`...`\n * GraphQL comment block\n *\n * This intentionally excludes Relay Classic tags, as Prettier does not\n * support Relay Classic formatting.\n */\n\n\nfunction isGraphQL(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  return hasLanguageComment(node, \"GraphQL\") || parent && (parent.type === \"TaggedTemplateExpression\" && (parent.tag.type === \"MemberExpression\" && parent.tag.object.name === \"graphql\" && parent.tag.property.name === \"experimental\" || parent.tag.type === \"Identifier\" && (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")) || parent.type === \"CallExpression\" && parent.callee.type === \"Identifier\" && parent.callee.name === \"graphql\");\n}\n\nfunction hasLanguageComment(node, languageName) {\n  // This checks for a leading comment that is exactly `/* GraphQL */`\n  // In order to be in line with other implementations of this comment tag\n  // we will not trim the comment value and we will expect exactly one space on\n  // either side of the GraphQL string\n  // Also see ./clean.js\n  return hasLeadingComment(node, function (comment) {\n    return isBlockComment(comment) && comment.value === \" \".concat(languageName, \" \");\n  });\n}\n\nfunction isPathMatch(path, predicateStack) {\n  var stack = path.stack.slice();\n  var name = null;\n  var node = stack.pop();\n\n  var _iterator = _createForOfIteratorHelper(predicateStack),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var predicate = _step.value;\n\n      if (node === undefined) {\n        return false;\n      } // skip index/array\n\n\n      if (typeof name === \"number\") {\n        name = stack.pop();\n        node = stack.pop();\n      }\n\n      if (!predicate(node, name)) {\n        return false;\n      }\n\n      name = stack.pop();\n      node = stack.pop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return true;\n}\n/**\n *     - html`...`\n *     - HTML comment block\n */\n\n\nfunction isHtml(path) {\n  var node = path.getValue();\n  return hasLanguageComment(node, \"HTML\") || isPathMatch(path, [function (node) {\n    return node.type === \"TemplateLiteral\";\n  }, function (node, name) {\n    return node.type === \"TaggedTemplateExpression\" && node.tag.type === \"Identifier\" && node.tag.name === \"html\" && name === \"quasi\";\n  }]);\n} // The counter is needed to distinguish nested embeds.\n\n\nvar htmlTemplateLiteralCounter = 0;\n\nfunction printHtmlTemplateLiteral(path, print, textToDoc, parser, escapeClosingScriptTag) {\n  var node = path.getValue();\n  var counter = htmlTemplateLiteralCounter;\n  htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;\n\n  var composePlaceholder = function composePlaceholder(index) {\n    return \"PRETTIER_HTML_PLACEHOLDER_\".concat(index, \"_\").concat(counter, \"_IN_JS\");\n  };\n\n  var text = node.quasis.map(function (quasi, index, quasis) {\n    return index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index);\n  }).join(\"\");\n  var expressionDocs = path.map(print, \"expressions\");\n\n  if (expressionDocs.length === 0 && text.trim().length === 0) {\n    return \"``\";\n  }\n\n  var placeholderRegex = RegExp(composePlaceholder(\"(\\\\d+)\"), \"g\");\n  var contentDoc = mapDoc(stripTrailingHardline(textToDoc(text, {\n    parser: parser\n  })), function (doc) {\n    if (typeof doc !== \"string\") {\n      return doc;\n    }\n\n    var parts = [];\n    var components = doc.split(placeholderRegex);\n\n    for (var i = 0; i < components.length; i++) {\n      var component = components[i];\n\n      if (i % 2 === 0) {\n        if (component) {\n          component = uncook(component);\n\n          if (escapeClosingScriptTag) {\n            component = component.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\");\n          }\n\n          parts.push(component);\n        }\n\n        continue;\n      }\n\n      var placeholderIndex = +component;\n      parts.push(concat([\"${\", group(expressionDocs[placeholderIndex]), \"}\"]));\n    }\n\n    return concat(parts);\n  });\n  return group(concat([\"`\", indent(concat([hardline, group(contentDoc)])), softline, \"`\"]));\n}\n\nmodule.exports = embed;","map":null,"metadata":{},"sourceType":"script"}