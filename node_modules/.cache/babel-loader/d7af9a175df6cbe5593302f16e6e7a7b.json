{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.msg = msg;\nexports.access = access;\nexports.assertRootMode = assertRootMode;\nexports.assertSourceMaps = assertSourceMaps;\nexports.assertCompact = assertCompact;\nexports.assertSourceType = assertSourceType;\nexports.assertCallerMetadata = assertCallerMetadata;\nexports.assertInputSourceMap = assertInputSourceMap;\nexports.assertString = assertString;\nexports.assertFunction = assertFunction;\nexports.assertBoolean = assertBoolean;\nexports.assertObject = assertObject;\nexports.assertArray = assertArray;\nexports.assertIgnoreList = assertIgnoreList;\nexports.assertConfigApplicableTest = assertConfigApplicableTest;\nexports.assertConfigFileSearch = assertConfigFileSearch;\nexports.assertBabelrcSearch = assertBabelrcSearch;\nexports.assertPluginList = assertPluginList;\nexports.assertTargets = assertTargets;\nexports.assertAssumptions = assertAssumptions;\n\nfunction _helperCompilationTargets() {\n  var data = require(\"@babel/helper-compilation-targets\");\n\n  _helperCompilationTargets = function _helperCompilationTargets() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./options\");\n\nfunction msg(loc) {\n  switch (loc.type) {\n    case \"root\":\n      return \"\";\n\n    case \"env\":\n      return \"\".concat(msg(loc.parent), \".env[\\\"\").concat(loc.name, \"\\\"]\");\n\n    case \"overrides\":\n      return \"\".concat(msg(loc.parent), \".overrides[\").concat(loc.index, \"]\");\n\n    case \"option\":\n      return \"\".concat(msg(loc.parent), \".\").concat(loc.name);\n\n    case \"access\":\n      return \"\".concat(msg(loc.parent), \"[\").concat(JSON.stringify(loc.name), \"]\");\n\n    default:\n      throw new Error(\"Assertion failure: Unknown type \".concat(loc.type));\n  }\n}\n\nfunction access(loc, name) {\n  return {\n    type: \"access\",\n    name: name,\n    parent: loc\n  };\n}\n\nfunction assertRootMode(loc, value) {\n  if (value !== undefined && value !== \"root\" && value !== \"upward\" && value !== \"upward-optional\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a \\\"root\\\", \\\"upward\\\", \\\"upward-optional\\\" or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertSourceMaps(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"inline\" && value !== \"both\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a boolean, \\\"inline\\\", \\\"both\\\", or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertCompact(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"auto\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a boolean, \\\"auto\\\", or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertSourceType(loc, value) {\n  if (value !== undefined && value !== \"module\" && value !== \"script\" && value !== \"unambiguous\") {\n    throw new Error(\"\".concat(msg(loc), \" must be \\\"module\\\", \\\"script\\\", \\\"unambiguous\\\", or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertCallerMetadata(loc, value) {\n  var obj = assertObject(loc, value);\n\n  if (obj) {\n    if (typeof obj.name !== \"string\") {\n      throw new Error(\"\".concat(msg(loc), \" set but does not contain \\\"name\\\" property string\"));\n    }\n\n    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n      var prop = _Object$keys[_i];\n      var propLoc = access(loc, prop);\n      var _value = obj[prop];\n\n      if (_value != null && typeof _value !== \"boolean\" && typeof _value !== \"string\" && typeof _value !== \"number\") {\n        throw new Error(\"\".concat(msg(propLoc), \" must be null, undefined, a boolean, a string, or a number.\"));\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction assertInputSourceMap(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && (typeof value !== \"object\" || !value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be a boolean, object, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertString(loc, value) {\n  if (value !== undefined && typeof value !== \"string\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a string, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertFunction(loc, value) {\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a function, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertBoolean(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a boolean, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertObject(loc, value) {\n  if (value !== undefined && (typeof value !== \"object\" || Array.isArray(value) || !value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be an object, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertArray(loc, value) {\n  if (value != null && !Array.isArray(value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be an array, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertIgnoreList(loc, value) {\n  var arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach(function (item, i) {\n      return assertIgnoreItem(access(loc, i), item);\n    });\n  }\n\n  return arr;\n}\n\nfunction assertIgnoreItem(loc, value) {\n  if (typeof value !== \"string\" && typeof value !== \"function\" && !(value instanceof RegExp)) {\n    throw new Error(\"\".concat(msg(loc), \" must be an array of string/Function/RegExp values, or undefined\"));\n  }\n\n  return value;\n}\n\nfunction assertConfigApplicableTest(loc, value) {\n  if (value === undefined) return value;\n\n  if (Array.isArray(value)) {\n    value.forEach(function (item, i) {\n      if (!checkValidTest(item)) {\n        throw new Error(\"\".concat(msg(access(loc, i)), \" must be a string/Function/RegExp.\"));\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be a string/Function/RegExp, or an array of those\"));\n  }\n\n  return value;\n}\n\nfunction checkValidTest(value) {\n  return typeof value === \"string\" || typeof value === \"function\" || value instanceof RegExp;\n}\n\nfunction assertConfigFileSearch(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && typeof value !== \"string\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a undefined, a boolean, a string, \") + \"got \".concat(JSON.stringify(value)));\n  }\n\n  return value;\n}\n\nfunction assertBabelrcSearch(loc, value) {\n  if (value === undefined || typeof value === \"boolean\") return value;\n\n  if (Array.isArray(value)) {\n    value.forEach(function (item, i) {\n      if (!checkValidTest(item)) {\n        throw new Error(\"\".concat(msg(access(loc, i)), \" must be a string/Function/RegExp.\"));\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be a undefined, a boolean, a string/Function/RegExp \") + \"or an array of those, got \".concat(JSON.stringify(value)));\n  }\n\n  return value;\n}\n\nfunction assertPluginList(loc, value) {\n  var arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach(function (item, i) {\n      return assertPluginItem(access(loc, i), item);\n    });\n  }\n\n  return arr;\n}\n\nfunction assertPluginItem(loc, value) {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new Error(\"\".concat(msg(loc), \" must include an object\"));\n    }\n\n    if (value.length > 3) {\n      throw new Error(\"\".concat(msg(loc), \" may only be a two-tuple or three-tuple\"));\n    }\n\n    assertPluginTarget(access(loc, 0), value[0]);\n\n    if (value.length > 1) {\n      var opts = value[1];\n\n      if (opts !== undefined && opts !== false && (typeof opts !== \"object\" || Array.isArray(opts) || opts === null)) {\n        throw new Error(\"\".concat(msg(access(loc, 1)), \" must be an object, false, or undefined\"));\n      }\n    }\n\n    if (value.length === 3) {\n      var name = value[2];\n\n      if (name !== undefined && typeof name !== \"string\") {\n        throw new Error(\"\".concat(msg(access(loc, 2)), \" must be a string, or undefined\"));\n      }\n    }\n  } else {\n    assertPluginTarget(loc, value);\n  }\n\n  return value;\n}\n\nfunction assertPluginTarget(loc, value) {\n  if ((typeof value !== \"object\" || !value) && typeof value !== \"string\" && typeof value !== \"function\") {\n    throw new Error(\"\".concat(msg(loc), \" must be a string, object, function\"));\n  }\n\n  return value;\n}\n\nfunction assertTargets(loc, value) {\n  if ((0, _helperCompilationTargets().isBrowsersQueryValid)(value)) return value;\n\n  if (typeof value !== \"object\" || !value || Array.isArray(value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be a string, an array of strings or an object\"));\n  }\n\n  var browsersLoc = access(loc, \"browsers\");\n  var esmodulesLoc = access(loc, \"esmodules\");\n  assertBrowsersList(browsersLoc, value.browsers);\n  assertBoolean(esmodulesLoc, value.esmodules);\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(value); _i2 < _Object$keys2.length; _i2++) {\n    var key = _Object$keys2[_i2];\n    var val = value[key];\n    var subLoc = access(loc, key);\n    if (key === \"esmodules\") assertBoolean(subLoc, val);else if (key === \"browsers\") assertBrowsersList(subLoc, val);else if (!Object.hasOwnProperty.call(_helperCompilationTargets().TargetNames, key)) {\n      var validTargets = Object.keys(_helperCompilationTargets().TargetNames).join(\", \");\n      throw new Error(\"\".concat(msg(subLoc), \" is not a valid target. Supported targets are \").concat(validTargets));\n    } else assertBrowserVersion(subLoc, val);\n  }\n\n  return value;\n}\n\nfunction assertBrowsersList(loc, value) {\n  if (value !== undefined && !(0, _helperCompilationTargets().isBrowsersQueryValid)(value)) {\n    throw new Error(\"\".concat(msg(loc), \" must be undefined, a string or an array of strings\"));\n  }\n}\n\nfunction assertBrowserVersion(loc, value) {\n  if (typeof value === \"number\" && Math.round(value) === value) return;\n  if (typeof value === \"string\") return;\n  throw new Error(\"\".concat(msg(loc), \" must be a string or an integer number\"));\n}\n\nfunction assertAssumptions(loc, value) {\n  if (value === undefined) return;\n\n  if (typeof value !== \"object\" || value === null) {\n    throw new Error(\"\".concat(msg(loc), \" must be an object or undefined.\"));\n  }\n\n  var root = loc;\n\n  do {\n    root = root.parent;\n  } while (root.type !== \"root\");\n\n  var inPreset = root.source === \"preset\";\n\n  for (var _i3 = 0, _Object$keys3 = Object.keys(value); _i3 < _Object$keys3.length; _i3++) {\n    var name = _Object$keys3[_i3];\n    var subLoc = access(loc, name);\n\n    if (!_options.assumptionsNames.has(name)) {\n      throw new Error(\"\".concat(msg(subLoc), \" is not a supported assumption.\"));\n    }\n\n    if (typeof value[name] !== \"boolean\") {\n      throw new Error(\"\".concat(msg(subLoc), \" must be a boolean.\"));\n    }\n\n    if (inPreset && value[name] === false) {\n      throw new Error(\"\".concat(msg(subLoc), \" cannot be set to 'false' inside presets.\"));\n    }\n  }\n\n  return value;\n}","map":null,"metadata":{},"sourceType":"script"}