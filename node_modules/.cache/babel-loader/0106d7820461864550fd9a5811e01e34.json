{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar assert = require(\"assert\");\n\nvar util = require(\"../common/util\");\n\nvar comments = require(\"./comments\");\n\nvar _require = require(\"./utils\"),\n    getLeftSidePathName = _require.getLeftSidePathName,\n    hasNakedLeftSide = _require.hasNakedLeftSide,\n    hasFlowShorthandAnnotationComment = _require.hasFlowShorthandAnnotationComment;\n\nfunction hasClosureCompilerTypeCastComment(text, path) {\n  // https://github.com/google/closure-compiler/wiki/Annotating-Types#type-casts\n  // Syntax example: var x = /** @type {string} */ (fruit);\n  var n = path.getValue();\n  return isParenthesized(n) && (hasTypeCastComment(n) || hasAncestorTypeCastComment(0)); // for sub-item: /** @type {array} */ (numberOrString).map(x => x);\n\n  function hasAncestorTypeCastComment(index) {\n    var ancestor = path.getParentNode(index);\n    return ancestor && !isParenthesized(ancestor) ? hasTypeCastComment(ancestor) || hasAncestorTypeCastComment(index + 1) : false;\n  }\n\n  function hasTypeCastComment(node) {\n    return node.comments && node.comments.some(function (comment) {\n      return comment.leading && comments.isBlockComment(comment) && isTypeCastComment(comment.value);\n    });\n  }\n\n  function isParenthesized(node) {\n    // Closure typecast comments only really make sense when _not_ using\n    // typescript or flow parsers, so we take advantage of the babel parser's\n    // parenthesized expressions.\n    return node.extra && node.extra.parenthesized;\n  }\n\n  function isTypeCastComment(comment) {\n    var cleaned = comment.trim().split(\"\\n\").map(function (line) {\n      return line.replace(/^[\\s*]+/, \"\");\n    }).join(\" \").trim();\n\n    if (!/^@type\\s*\\{[^]+\\}$/.test(cleaned)) {\n      return false;\n    }\n\n    var isCompletelyClosed = false;\n    var unpairedBracketCount = 0;\n\n    var _iterator = _createForOfIteratorHelper(cleaned),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _char = _step.value;\n\n        if (_char === \"{\") {\n          if (isCompletelyClosed) {\n            return false;\n          }\n\n          unpairedBracketCount++;\n        } else if (_char === \"}\") {\n          if (unpairedBracketCount === 0) {\n            return false;\n          }\n\n          unpairedBracketCount--;\n\n          if (unpairedBracketCount === 0) {\n            isCompletelyClosed = true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return unpairedBracketCount === 0;\n  }\n}\n\nfunction needsParens(path, options) {\n  var parent = path.getParentNode();\n\n  if (!parent) {\n    return false;\n  }\n\n  var name = path.getName();\n  var node = path.getNode(); // If the value of this path is some child of a Node and not a Node\n  // itself, then it doesn't need parentheses. Only Node objects (in\n  // fact, only Expression nodes) need parentheses.\n\n  if (path.getValue() !== node) {\n    return false;\n  } // to avoid unexpected `}}` in HTML interpolations\n\n\n  if (options.__isInHtmlInterpolation && !options.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path)) {\n    return true;\n  } // Only statements don't need parentheses.\n\n\n  if (isStatement(node)) {\n    return false;\n  } // Closure compiler requires that type casted expressions to be surrounded by\n  // parentheses.\n\n\n  if (hasClosureCompilerTypeCastComment(options.originalText, path)) {\n    return true;\n  }\n\n  if ( // Preserve parens if we have a Flow annotation comment, unless we're using the Flow\n  // parser. The Flow parser turns Flow comments into type annotation nodes in its\n  // AST, which we handle separately.\n  options.parser !== \"flow\" && hasFlowShorthandAnnotationComment(path.getValue())) {\n    return true;\n  } // Identifiers never need parentheses.\n\n\n  if (node.type === \"Identifier\") {\n    // ...unless those identifiers are embed placeholders. They might be substituted by complex\n    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):\n    //     let tpl = html`<script> f((${expr}) / 2); </script>`;\n    // If the inner JS formatter removes the parens, the expression might change its meaning:\n    //     f((a + b) / 2)  vs  f(a + b / 2)\n    if (node.extra && node.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (parent.type === \"ParenthesizedExpression\") {\n    return false;\n  } // Add parens around the extends clause of a class. It is needed for almost\n  // all expressions.\n\n\n  if ((parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") && parent.superClass === node && (node.type === \"ArrowFunctionExpression\" || node.type === \"AssignmentExpression\" || node.type === \"AwaitExpression\" || node.type === \"BinaryExpression\" || node.type === \"ConditionalExpression\" || node.type === \"LogicalExpression\" || node.type === \"NewExpression\" || node.type === \"ObjectExpression\" || node.type === \"ParenthesizedExpression\" || node.type === \"SequenceExpression\" || node.type === \"TaggedTemplateExpression\" || node.type === \"UnaryExpression\" || node.type === \"UpdateExpression\" || node.type === \"YieldExpression\")) {\n    return true;\n  } // `export default function` or `export default class` can't be followed by\n  // anything after. So an expression like `export default (function(){}).toString()`\n  // needs to be followed by a parentheses\n\n\n  if (parent.type === \"ExportDefaultDeclaration\") {\n    return shouldWrapFunctionForExportDefault(path, options);\n  }\n\n  if (parent.type === \"Decorator\" && parent.expression === node) {\n    var hasCallExpression = false;\n    var hasMemberExpression = false;\n    var current = node;\n\n    while (current) {\n      switch (current.type) {\n        case \"MemberExpression\":\n          hasMemberExpression = true;\n          current = current.object;\n          break;\n\n        case \"CallExpression\":\n          if (\n          /** @(x().y) */\n          hasMemberExpression ||\n          /** @(x().y()) */\n          hasCallExpression) {\n            return true;\n          }\n\n          hasCallExpression = true;\n          current = current.callee;\n          break;\n\n        case \"Identifier\":\n          return false;\n\n        default:\n          return true;\n      }\n    }\n\n    return true;\n  }\n\n  if (parent.type === \"ArrowFunctionExpression\" && parent.body === node && node.type !== \"SequenceExpression\" && // these have parens added anyway\n  util.startsWithNoLookaheadToken(node,\n  /* forbidFunctionClassAndDoExpr */\n  false) || parent.type === \"ExpressionStatement\" && util.startsWithNoLookaheadToken(node,\n  /* forbidFunctionClassAndDoExpr */\n  true)) {\n    return true;\n  }\n\n  switch (node.type) {\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n\n    case \"UpdateExpression\":\n      if (parent.type === \"UnaryExpression\") {\n        return node.prefix && (node.operator === \"++\" && parent.operator === \"+\" || node.operator === \"--\" && parent.operator === \"-\");\n      }\n\n    // else fallthrough\n\n    case \"UnaryExpression\":\n      switch (parent.type) {\n        case \"UnaryExpression\":\n          return node.operator === parent.operator && (node.operator === \"+\" || node.operator === \"-\");\n\n        case \"BindExpression\":\n          return true;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"TaggedTemplateExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"BinaryExpression\":\n          return parent.operator === \"**\" && name === \"left\";\n\n        case \"TSNonNullExpression\":\n          return true;\n\n        default:\n          return false;\n      }\n\n    case \"BinaryExpression\":\n      {\n        if (parent.type === \"UpdateExpression\") {\n          return true;\n        }\n\n        var isLeftOfAForStatement = function isLeftOfAForStatement(node) {\n          var i = 0;\n\n          while (node) {\n            var _parent = path.getParentNode(i++);\n\n            if (!_parent) {\n              return false;\n            }\n\n            if (_parent.type === \"ForStatement\" && _parent.init === node) {\n              return true;\n            }\n\n            node = _parent;\n          }\n\n          return false;\n        };\n\n        if (node.operator === \"in\" && isLeftOfAForStatement(node)) {\n          return true;\n        }\n      }\n    // fallthrough\n\n    case \"TSTypeAssertion\":\n    case \"TSAsExpression\":\n    case \"LogicalExpression\":\n      switch (parent.type) {\n        case \"ConditionalExpression\":\n          return node.type === \"TSAsExpression\";\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ClassExpression\":\n        case \"ClassDeclaration\":\n          return name === \"superClass\" && parent.superClass === node;\n\n        case \"TSTypeAssertion\":\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"JSXSpreadAttribute\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BindExpression\":\n        case \"AwaitExpression\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"UpdateExpression\":\n          return true;\n\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        case \"AssignmentExpression\":\n          return parent.left === node && (node.type === \"TSTypeAssertion\" || node.type === \"TSAsExpression\");\n\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          {\n            if (!node.operator && node.type !== \"TSTypeAssertion\") {\n              return true;\n            }\n\n            var po = parent.operator;\n            var pp = util.getPrecedence(po);\n            var no = node.operator;\n            var np = util.getPrecedence(no);\n\n            if (pp > np) {\n              return true;\n            }\n\n            if ((po === \"||\" || po === \"??\") && no === \"&&\") {\n              return true;\n            }\n\n            if (pp === np && name === \"right\") {\n              assert.strictEqual(parent.right, node);\n              return true;\n            }\n\n            if (pp === np && !util.shouldFlatten(po, no)) {\n              return true;\n            }\n\n            if (pp < np && no === \"%\") {\n              return po === \"+\" || po === \"-\";\n            } // Add parenthesis when working with bitwise operators\n            // It's not stricly needed but helps with code understanding\n\n\n            if (util.isBitwiseOperator(po)) {\n              return true;\n            }\n\n            return false;\n          }\n\n        default:\n          return false;\n      }\n\n    case \"TSParenthesizedType\":\n      {\n        var grandParent = path.getParentNode(1);\n        /**\n         * const foo = (): (() => void) => (): void => null;\n         *                 ^          ^\n         */\n\n        if (getUnparenthesizedNode(node).type === \"TSFunctionType\" && parent.type === \"TSTypeAnnotation\" && grandParent.type === \"ArrowFunctionExpression\" && grandParent.returnType === parent) {\n          return true;\n        }\n\n        if ((parent.type === \"TSTypeParameter\" || parent.type === \"TypeParameter\" || parent.type === \"TSTypeAliasDeclaration\" || parent.type === \"TSTypeAnnotation\" || parent.type === \"TSParenthesizedType\" || parent.type === \"TSTypeParameterInstantiation\") && grandParent.type !== \"TSTypeOperator\" && grandParent.type !== \"TSOptionalType\") {\n          return false;\n        } // Delegate to inner TSParenthesizedType\n\n\n        if (node.typeAnnotation.type === \"TSParenthesizedType\" && parent.type !== \"TSArrayType\") {\n          return false;\n        }\n\n        return true;\n      }\n\n    case \"SequenceExpression\":\n      switch (parent.type) {\n        case \"ReturnStatement\":\n          return false;\n\n        case \"ForStatement\":\n          // Although parentheses wouldn't hurt around sequence\n          // expressions in the head of for loops, traditional style\n          // dictates that e.g. i++, j++ should not be wrapped with\n          // parentheses.\n          return false;\n\n        case \"ExpressionStatement\":\n          return name !== \"expression\";\n\n        case \"ArrowFunctionExpression\":\n          // We do need parentheses, but SequenceExpressions are handled\n          // specially when printing bodies of arrow functions.\n          return name !== \"body\";\n\n        default:\n          // Otherwise err on the side of overparenthesization, adding\n          // explicit exceptions above if this proves overzealous.\n          return true;\n      }\n\n    case \"YieldExpression\":\n      if (parent.type === \"UnaryExpression\" || parent.type === \"AwaitExpression\" || parent.type === \"TSAsExpression\" || parent.type === \"TSNonNullExpression\") {\n        return true;\n      }\n\n    // else fallthrough\n\n    case \"AwaitExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"BindExpression\":\n        case \"OptionalMemberExpression\":\n          return true;\n\n        case \"MemberExpression\":\n          return parent.object === node;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return parent.test === node;\n\n        default:\n          return false;\n      }\n\n    case \"ArrayTypeAnnotation\":\n      return parent.type === \"NullableTypeAnnotation\";\n\n    case \"IntersectionTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n      return parent.type === \"ArrayTypeAnnotation\" || parent.type === \"NullableTypeAnnotation\" || parent.type === \"IntersectionTypeAnnotation\" || parent.type === \"UnionTypeAnnotation\";\n\n    case \"NullableTypeAnnotation\":\n      return parent.type === \"ArrayTypeAnnotation\";\n\n    case \"FunctionTypeAnnotation\":\n      {\n        var ancestor = parent.type === \"NullableTypeAnnotation\" ? path.getParentNode(1) : parent;\n        return ancestor.type === \"UnionTypeAnnotation\" || ancestor.type === \"IntersectionTypeAnnotation\" || ancestor.type === \"ArrayTypeAnnotation\" || // We should check ancestor's parent to know whether the parentheses\n        // are really needed, but since ??T doesn't make sense this check\n        // will almost never be true.\n        ancestor.type === \"NullableTypeAnnotation\";\n      }\n\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"Literal\":\n      if (typeof node.value === \"string\" && parent.type === \"ExpressionStatement\" && ( // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n      // See corresponding workaround in printer.js case: \"Literal\"\n      options.parser !== \"typescript\" && !parent.directive || options.parser === \"typescript\" && options.originalText.substr(options.locStart(node) - 1, 1) === \"(\")) {\n        // To avoid becoming a directive\n        var _grandParent = path.getParentNode(1);\n\n        return _grandParent.type === \"Program\" || _grandParent.type === \"BlockStatement\";\n      }\n\n      return parent.type === \"MemberExpression\" && typeof node.value === \"number\" && name === \"object\" && parent.object === node;\n\n    case \"AssignmentExpression\":\n      {\n        var _grandParent2 = path.getParentNode(1);\n\n        if (parent.type === \"ArrowFunctionExpression\" && parent.body === node) {\n          return true;\n        } else if (parent.type === \"ClassProperty\" && parent.key === node && parent.computed) {\n          return false;\n        } else if (parent.type === \"TSPropertySignature\" && parent.name === node) {\n          return false;\n        } else if (parent.type === \"ForStatement\" && (parent.init === node || parent.update === node)) {\n          return false;\n        } else if (parent.type === \"ExpressionStatement\") {\n          return node.left.type === \"ObjectPattern\";\n        } else if (parent.type === \"TSPropertySignature\" && parent.key === node) {\n          return false;\n        } else if (parent.type === \"AssignmentExpression\") {\n          return false;\n        } else if (parent.type === \"SequenceExpression\" && _grandParent2 && _grandParent2.type === \"ForStatement\" && (_grandParent2.init === parent || _grandParent2.update === parent)) {\n          return false;\n        } else if (parent.type === \"Property\" && parent.value === node) {\n          return false;\n        } else if (parent.type === \"NGChainedExpression\") {\n          return false;\n        }\n\n        return true;\n      }\n\n    case \"ConditionalExpression\":\n      switch (parent.type) {\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n        case \"NGPipeExpression\":\n        case \"ExportDefaultDeclaration\":\n        case \"AwaitExpression\":\n        case \"JSXSpreadAttribute\":\n        case \"TSTypeAssertion\":\n        case \"TypeCastExpression\":\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"OptionalMemberExpression\":\n          return true;\n\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        case \"ConditionalExpression\":\n          return name === \"test\" && parent.test === node;\n\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n\n        default:\n          return false;\n      }\n\n    case \"FunctionExpression\":\n      switch (parent.type) {\n        case \"NewExpression\":\n        case \"CallExpression\":\n          return name === \"callee\";\n        // Not strictly necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.\n\n        case \"TaggedTemplateExpression\":\n          return true;\n        // This is basically a kind of IIFE.\n\n        default:\n          return false;\n      }\n\n    case \"ArrowFunctionExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n          return name === \"callee\";\n\n        case \"NewExpression\":\n          return name === \"callee\";\n\n        case \"MemberExpression\":\n          return name === \"object\";\n\n        case \"TSAsExpression\":\n        case \"BindExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"UnaryExpression\":\n        case \"LogicalExpression\":\n        case \"BinaryExpression\":\n        case \"AwaitExpression\":\n        case \"TSTypeAssertion\":\n          return true;\n\n        case \"ConditionalExpression\":\n          return name === \"test\";\n\n        default:\n          return false;\n      }\n\n    case \"ClassExpression\":\n      switch (parent.type) {\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n\n        default:\n          return false;\n      }\n\n    case \"OptionalMemberExpression\":\n      return parent.type === \"MemberExpression\";\n\n    case \"CallExpression\":\n    case \"MemberExpression\":\n    case \"TaggedTemplateExpression\":\n    case \"TSNonNullExpression\":\n      if ((parent.type === \"BindExpression\" || parent.type === \"NewExpression\") && name === \"callee\" && parent.callee === node) {\n        var object = node;\n\n        while (object) {\n          switch (object.type) {\n            case \"CallExpression\":\n              return true;\n\n            case \"MemberExpression\":\n            case \"BindExpression\":\n              object = object.object;\n              break;\n            // tagged templates are basically member expressions from a grammar perspective\n            // see https://tc39.github.io/ecma262/#prod-MemberExpression\n\n            case \"TaggedTemplateExpression\":\n              object = object.tag;\n              break;\n\n            case \"TSNonNullExpression\":\n              object = object.expression;\n              break;\n\n            default:\n              return false;\n          }\n        }\n      }\n\n      return false;\n\n    case \"BindExpression\":\n      if (parent.type === \"BindExpression\" && name === \"callee\" && parent.callee === node || parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node || parent.type === \"NewExpression\" && name === \"callee\" && parent.callee === node) {\n        return true;\n      }\n\n      return false;\n\n    case \"NGPipeExpression\":\n      if (parent.type === \"NGRoot\" || parent.type === \"NGMicrosyntaxExpression\" || parent.type === \"ObjectProperty\" || parent.type === \"ArrayExpression\" || (parent.type === \"CallExpression\" || parent.type === \"OptionalCallExpression\") && parent.arguments[name] === node || parent.type === \"NGPipeExpression\" && name === \"right\" || parent.type === \"MemberExpression\" && name === \"property\" || parent.type === \"AssignmentExpression\") {\n        return false;\n      }\n\n      return true;\n  }\n\n  return false;\n}\n\nfunction isStatement(node) {\n  return node.type === \"BlockStatement\" || node.type === \"BreakStatement\" || node.type === \"ClassBody\" || node.type === \"ClassDeclaration\" || node.type === \"ClassMethod\" || node.type === \"ClassProperty\" || node.type === \"ClassPrivateProperty\" || node.type === \"ContinueStatement\" || node.type === \"DebuggerStatement\" || node.type === \"DeclareClass\" || node.type === \"DeclareExportAllDeclaration\" || node.type === \"DeclareExportDeclaration\" || node.type === \"DeclareFunction\" || node.type === \"DeclareInterface\" || node.type === \"DeclareModule\" || node.type === \"DeclareModuleExports\" || node.type === \"DeclareVariable\" || node.type === \"DoWhileStatement\" || node.type === \"ExportAllDeclaration\" || node.type === \"ExportDefaultDeclaration\" || node.type === \"ExportNamedDeclaration\" || node.type === \"ExpressionStatement\" || node.type === \"ForAwaitStatement\" || node.type === \"ForInStatement\" || node.type === \"ForOfStatement\" || node.type === \"ForStatement\" || node.type === \"FunctionDeclaration\" || node.type === \"IfStatement\" || node.type === \"ImportDeclaration\" || node.type === \"InterfaceDeclaration\" || node.type === \"LabeledStatement\" || node.type === \"MethodDefinition\" || node.type === \"ReturnStatement\" || node.type === \"SwitchStatement\" || node.type === \"ThrowStatement\" || node.type === \"TryStatement\" || node.type === \"TSDeclareFunction\" || node.type === \"TSEnumDeclaration\" || node.type === \"TSImportEqualsDeclaration\" || node.type === \"TSInterfaceDeclaration\" || node.type === \"TSModuleDeclaration\" || node.type === \"TSNamespaceExportDeclaration\" || node.type === \"TypeAlias\" || node.type === \"VariableDeclaration\" || node.type === \"WhileStatement\" || node.type === \"WithStatement\";\n}\n\nfunction getUnparenthesizedNode(node) {\n  return node.type === \"TSParenthesizedType\" ? getUnparenthesizedNode(node.typeAnnotation) : node;\n}\n\nfunction endsWithRightBracket(node) {\n  switch (node.type) {\n    case \"ObjectExpression\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction isFollowedByRightBracket(path) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n  var name = path.getName();\n\n  switch (parent.type) {\n    case \"NGPipeExpression\":\n      if (typeof name === \"number\" && parent.arguments[name] === node && parent.arguments.length - 1 === name) {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"ObjectProperty\":\n      if (name === \"value\") {\n        var parentParent = path.getParentNode(1);\n        return parentParent.properties[parentParent.properties.length - 1] === parent;\n      }\n\n      break;\n\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      if (name === \"right\") {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n      if (name === \"alternate\") {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n\n    case \"UnaryExpression\":\n      if (parent.prefix) {\n        return path.callParent(isFollowedByRightBracket);\n      }\n\n      break;\n  }\n\n  return false;\n}\n\nfunction shouldWrapFunctionForExportDefault(path, options) {\n  var node = path.getValue();\n  var parent = path.getParentNode();\n\n  if (node.type === \"FunctionExpression\" || node.type === \"ClassExpression\") {\n    return parent.type === \"ExportDefaultDeclaration\" || // in some cases the function is already wrapped\n    // (e.g. `export default (function() {})();`)\n    // in this case we don't need to add extra parens\n    !needsParens(path, options);\n  }\n\n  if (!hasNakedLeftSide(node) || parent.type !== \"ExportDefaultDeclaration\" && needsParens(path, options)) {\n    return false;\n  }\n\n  return path.call.apply(path, [function (childPath) {\n    return shouldWrapFunctionForExportDefault(childPath, options);\n  }].concat(getLeftSidePathName(path, node)));\n}\n\nmodule.exports = needsParens;","map":null,"metadata":{},"sourceType":"script"}