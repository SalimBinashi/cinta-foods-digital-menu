{"ast":null,"code":"var State = require('./lib/state');\n\nvar tokenize = require('./lib/tokenize');\n\nvar tokenizedCache = {};\n\nmodule.exports = function jsonQuery(query, options) {\n  // extract params for ['test[param=?]', 'value'] type queries\n  var params = options && options.params || null;\n\n  if (Array.isArray(query)) {\n    params = query.slice(1);\n    query = query[0];\n  }\n\n  if (!tokenizedCache[query]) {\n    tokenizedCache[query] = tokenize(query, true);\n  }\n\n  return handleQuery(tokenizedCache[query], options, params);\n};\n\nmodule.exports.lastParent = function (query) {\n  var last = query.parents[query.parents.length - 1];\n\n  if (last) {\n    return last.value;\n  } else {\n    return null;\n  }\n};\n\nfunction handleQuery(tokens, options, params) {\n  var state = new State(options, params, handleQuery);\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (handleToken(tokens[i], state)) {\n      break;\n    }\n  } // flush\n\n\n  handleToken(null, state); // set databind hooks\n\n  if (state.currentItem instanceof Object) {\n    state.addReference(state.currentItem);\n  } else {\n    var parentObject = getLastParentObject(state.currentParents);\n\n    if (parentObject) {\n      state.addReference(parentObject);\n    }\n  }\n\n  return {\n    value: state.currentItem,\n    key: state.currentKey,\n    references: state.currentReferences,\n    parents: state.currentParents\n  };\n}\n\nfunction handleToken(token, state) {\n  // state: setCurrent, getValue, getValues, resetCurrent, deepQuery, rootContext, currentItem, currentKey, options, filters\n  if (token == null) {\n    // process end of query\n    if (!state.currentItem && state.options.force) {\n      state.force(state.options.force);\n    }\n  } else if (token.values) {\n    if (state.currentItem) {\n      var keys = Object.keys(state.currentItem);\n      var values = [];\n      keys.forEach(function (key) {\n        if (token.deep && Array.isArray(state.currentItem[key])) {\n          state.currentItem[key].forEach(function (item) {\n            values.push(item);\n          });\n        } else {\n          values.push(state.currentItem[key]);\n        }\n      });\n      state.setCurrent(keys, values);\n    } else {\n      state.setCurrent(keys, []);\n    }\n  } else if (token.get) {\n    var key = state.getValue(token.get);\n\n    if (shouldOverride(state, key)) {\n      state.setCurrent(key, state.override[key]);\n    } else {\n      if (state.currentItem || state.options.force && state.force({})) {\n        if (isDeepAccessor(state.currentItem, key) || token.multiple) {\n          var values = state.currentItem.map(function (item) {\n            return item[key];\n          }).filter(isDefined);\n          values = Array.prototype.concat.apply([], values); // flatten\n\n          state.setCurrent(key, values);\n        } else {\n          state.setCurrent(key, state.currentItem[key]);\n        }\n      } else {\n        state.setCurrent(key, null);\n      }\n    }\n  } else if (token.select) {\n    if (Array.isArray(state.currentItem) || state.options.force && state.force([])) {\n      var match = (token.boolean ? token.select : [token]).map(function (part) {\n        if (part.op === ':') {\n          var key = state.getValue(part.select[0]);\n          return {\n            func: function func(item) {\n              if (key) {\n                item = item[key];\n              }\n\n              return state.getValueFrom(part.select[1], item);\n            },\n            negate: part.negate,\n            booleanOp: part.booleanOp\n          };\n        } else {\n          var selector = state.getValues(part.select);\n          if (!state.options.allowRegexp && part.op === '~' && selector[1] instanceof RegExp) throw new Error('options.allowRegexp is not enabled.');\n          return {\n            key: selector[0],\n            value: selector[1],\n            negate: part.negate,\n            booleanOp: part.booleanOp,\n            op: part.op\n          };\n        }\n      });\n\n      if (token.multiple) {\n        var keys = [];\n        var value = [];\n        state.currentItem.forEach(function (item, i) {\n          if (matches(item, match)) {\n            keys.push(i);\n            value.push(item);\n          }\n        });\n        state.setCurrent(keys, value);\n      } else {\n        if (!state.currentItem.some(function (item, i) {\n          if (matches(item, match)) {\n            state.setCurrent(i, item);\n            return true;\n          }\n        })) {\n          state.setCurrent(null, null);\n        }\n      }\n    } else {\n      state.setCurrent(null, null);\n    }\n  } else if (token.root) {\n    state.resetCurrent();\n\n    if (token.args && token.args.length) {\n      state.setCurrent(null, state.getValue(token.args[0]));\n    } else {\n      state.setCurrent(null, state.rootContext);\n    }\n  } else if (token.parent) {\n    state.resetCurrent();\n    state.setCurrent(null, state.options.parent);\n  } else if (token.or) {\n    if (state.currentItem) {\n      return true;\n    } else {\n      state.resetCurrent();\n      state.setCurrent(null, state.context);\n    }\n  } else if (token.filter) {\n    var helper = state.getLocal(token.filter) || state.getGlobal(token.filter);\n\n    if (typeof helper === 'function') {\n      // function(input, args...)\n      var values = state.getValues(token.args || []);\n      var result = helper.apply(state.options, [state.currentItem].concat(values));\n      state.setCurrent(null, result);\n    } else {\n      // fallback to old filters\n      var filter = state.getFilter(token.filter);\n\n      if (typeof filter === 'function') {\n        var values = state.getValues(token.args || []);\n        var result = filter.call(state.options, state.currentItem, {\n          args: values,\n          state: state,\n          data: state.rootContext\n        });\n        state.setCurrent(null, result);\n      }\n    }\n  } else if (token.deep) {\n    if (state.currentItem) {\n      if (token.deep.length === 0) {\n        return;\n      }\n\n      var result = state.deepQuery(state.currentItem, token.deep, state.options);\n\n      if (result) {\n        state.setCurrent(result.key, result.value);\n\n        for (var i = 0; i < result.parents.length; i++) {\n          state.currentParents.push(result.parents[i]);\n        }\n      } else {\n        state.setCurrent(null, null);\n      }\n    } else {\n      state.currentItem = null;\n    }\n  }\n}\n\nfunction matches(item, parts) {\n  var result = false;\n\n  for (var i = 0; i < parts.length; i++) {\n    var opts = parts[i];\n    var r = false;\n\n    if (opts.func) {\n      r = opts.func(item);\n    } else if (opts.op === '~') {\n      if (opts.value instanceof RegExp) {\n        r = item[opts.key] && !!item[opts.key].match(opts.value);\n      } else {\n        r = item[opts.key] && !!~item[opts.key].indexOf(opts.value);\n      }\n    } else if (opts.op === '=') {\n      if (item[opts.key] === true && opts.value === 'true' || item[opts.key] === false && opts.value === 'false') {\n        r = true;\n      } else {\n        r = item[opts.key] == opts.value;\n      }\n    } else if (opts.op === '>') {\n      r = item[opts.key] > opts.value;\n    } else if (opts.op === '<') {\n      r = item[opts.key] < opts.value;\n    } else if (opts.op === '>=') {\n      r = item[opts.key] >= opts.value;\n    } else if (opts.op === '<=') {\n      r = item[opts.key] <= opts.value;\n    }\n\n    if (opts.negate) {\n      r = !r;\n    }\n\n    if (opts.booleanOp === '&') {\n      result = result && r;\n    } else if (opts.booleanOp === '|') {\n      result = result || r;\n    } else {\n      result = r;\n    }\n  }\n\n  return result;\n}\n\nfunction isDefined(value) {\n  return typeof value !== 'undefined';\n}\n\nfunction shouldOverride(state, key) {\n  return state.override && state.currentItem === state.rootContext && state.override[key] !== undefined;\n}\n\nfunction isDeepAccessor(currentItem, key) {\n  return currentItem instanceof Array && parseInt(key) != key;\n}\n\nfunction getLastParentObject(parents) {\n  for (var i = 0; i < parents.length; i++) {\n    if (!parents[i + 1] || !(parents[i + 1].value instanceof Object)) {\n      return parents[i].value;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}