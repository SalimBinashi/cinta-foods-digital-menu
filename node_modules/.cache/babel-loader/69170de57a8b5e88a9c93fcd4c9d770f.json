{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = mergeSourceMap;\n\nfunction _sourceMap() {\n  var data = _interopRequireDefault(require(\"source-map\"));\n\n  _sourceMap = function _sourceMap() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction mergeSourceMap(inputMap, map) {\n  var input = buildMappingData(inputMap);\n  var output = buildMappingData(map);\n  var mergedGenerator = new (_sourceMap().default.SourceMapGenerator)();\n\n  var _iterator = _createForOfIteratorHelper(input.sources),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _ref = _step.value;\n      var source = _ref.source;\n\n      if (typeof source.content === \"string\") {\n        mergedGenerator.setSourceContent(source.path, source.content);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (output.sources.length === 1) {\n    var defaultSource = output.sources[0];\n    var insertedMappings = new Map();\n    eachInputGeneratedRange(input, function (generated, original, source) {\n      eachOverlappingGeneratedOutputRange(defaultSource, generated, function (item) {\n        var key = makeMappingKey(item);\n        if (insertedMappings.has(key)) return;\n        insertedMappings.set(key, item);\n        mergedGenerator.addMapping({\n          source: source.path,\n          original: {\n            line: original.line,\n            column: original.columnStart\n          },\n          generated: {\n            line: item.line,\n            column: item.columnStart\n          },\n          name: original.name\n        });\n      });\n    });\n\n    var _iterator2 = _createForOfIteratorHelper(insertedMappings.values()),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var item = _step2.value;\n\n        if (item.columnEnd === Infinity) {\n          continue;\n        }\n\n        var clearItem = {\n          line: item.line,\n          columnStart: item.columnEnd\n        };\n        var key = makeMappingKey(clearItem);\n\n        if (insertedMappings.has(key)) {\n          continue;\n        }\n\n        mergedGenerator.addMapping({\n          generated: {\n            line: clearItem.line,\n            column: clearItem.columnStart\n          }\n        });\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  var result = mergedGenerator.toJSON();\n\n  if (typeof input.sourceRoot === \"string\") {\n    result.sourceRoot = input.sourceRoot;\n  }\n\n  return result;\n}\n\nfunction makeMappingKey(item) {\n  return \"\".concat(item.line, \"/\").concat(item.columnStart);\n}\n\nfunction eachOverlappingGeneratedOutputRange(outputFile, inputGeneratedRange, callback) {\n  var overlappingOriginal = filterApplicableOriginalRanges(outputFile, inputGeneratedRange);\n\n  var _iterator3 = _createForOfIteratorHelper(overlappingOriginal),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _ref2 = _step3.value;\n      var generated = _ref2.generated;\n\n      var _iterator4 = _createForOfIteratorHelper(generated),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var item = _step4.value;\n          callback(item);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\n\nfunction filterApplicableOriginalRanges(_ref5, _ref6) {\n  var mappings = _ref5.mappings;\n  var line = _ref6.line,\n      columnStart = _ref6.columnStart,\n      columnEnd = _ref6.columnEnd;\n  return filterSortedArray(mappings, function (_ref7) {\n    var outOriginal = _ref7.original;\n    if (line > outOriginal.line) return -1;\n    if (line < outOriginal.line) return 1;\n    if (columnStart >= outOriginal.columnEnd) return -1;\n    if (columnEnd <= outOriginal.columnStart) return 1;\n    return 0;\n  });\n}\n\nfunction eachInputGeneratedRange(map, callback) {\n  var _iterator5 = _createForOfIteratorHelper(map.sources),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _ref3 = _step5.value;\n      var source = _ref3.source,\n          mappings = _ref3.mappings;\n\n      var _iterator6 = _createForOfIteratorHelper(mappings),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _ref4 = _step6.value;\n          var original = _ref4.original,\n              generated = _ref4.generated;\n\n          var _iterator7 = _createForOfIteratorHelper(generated),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var item = _step7.value;\n              callback(item, original, source);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n}\n\nfunction buildMappingData(map) {\n  var consumer = new (_sourceMap().default.SourceMapConsumer)(Object.assign({}, map, {\n    sourceRoot: null\n  }));\n  var sources = new Map();\n  var mappings = new Map();\n  var last = null;\n  consumer.computeColumnSpans();\n  consumer.eachMapping(function (m) {\n    if (m.originalLine === null) return;\n    var source = sources.get(m.source);\n\n    if (!source) {\n      source = {\n        path: m.source,\n        content: consumer.sourceContentFor(m.source, true)\n      };\n      sources.set(m.source, source);\n    }\n\n    var sourceData = mappings.get(source);\n\n    if (!sourceData) {\n      sourceData = {\n        source: source,\n        mappings: []\n      };\n      mappings.set(source, sourceData);\n    }\n\n    var obj = {\n      line: m.originalLine,\n      columnStart: m.originalColumn,\n      columnEnd: Infinity,\n      name: m.name\n    };\n\n    if (last && last.source === source && last.mapping.line === m.originalLine) {\n      last.mapping.columnEnd = m.originalColumn;\n    }\n\n    last = {\n      source: source,\n      mapping: obj\n    };\n    sourceData.mappings.push({\n      original: obj,\n      generated: consumer.allGeneratedPositionsFor({\n        source: m.source,\n        line: m.originalLine,\n        column: m.originalColumn\n      }).map(function (item) {\n        return {\n          line: item.line,\n          columnStart: item.column,\n          columnEnd: item.lastColumn + 1\n        };\n      })\n    });\n  }, null, _sourceMap().default.SourceMapConsumer.ORIGINAL_ORDER);\n  return {\n    file: map.file,\n    sourceRoot: map.sourceRoot,\n    sources: Array.from(mappings.values())\n  };\n}\n\nfunction findInsertionLocation(array, callback) {\n  var left = 0;\n  var right = array.length;\n\n  while (left < right) {\n    var mid = Math.floor((left + right) / 2);\n    var item = array[mid];\n    var result = callback(item);\n\n    if (result === 0) {\n      left = mid;\n      break;\n    }\n\n    if (result >= 0) {\n      right = mid;\n    } else {\n      left = mid + 1;\n    }\n  }\n\n  var i = left;\n\n  if (i < array.length) {\n    while (i >= 0 && callback(array[i]) >= 0) {\n      i--;\n    }\n\n    return i + 1;\n  }\n\n  return i;\n}\n\nfunction filterSortedArray(array, callback) {\n  var start = findInsertionLocation(array, callback);\n  var results = [];\n\n  for (var i = start; i < array.length && callback(array[i]) === 0; i++) {\n    results.push(array[i]);\n  }\n\n  return results;\n}","map":null,"metadata":{},"sourceType":"script"}