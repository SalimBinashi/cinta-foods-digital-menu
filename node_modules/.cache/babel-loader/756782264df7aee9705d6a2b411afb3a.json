{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = require(\"@babel/types\");\n\nvar referenceVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      var scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    var binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    var _iterator = _createForOfIteratorHelper(binding.constantViolations),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var violation = _step.value;\n\n        if (violation.scope !== binding.path.scope) {\n          state.mutableBinding = true;\n          path.stop();\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n};\n\nvar PathHoister = /*#__PURE__*/function () {\n  function PathHoister(path, scope) {\n    _classCallCheck(this, PathHoister);\n\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  _createClass(PathHoister, [{\n    key: \"isCompatibleScope\",\n    value: function isCompatibleScope(scope) {\n      for (var _i = 0, _Object$keys = Object.keys(this.bindings); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        var binding = this.bindings[key];\n\n        if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"getCompatibleScopes\",\n    value: function getCompatibleScopes() {\n      var scope = this.path.scope;\n\n      do {\n        if (this.isCompatibleScope(scope)) {\n          this.scopes.push(scope);\n        } else {\n          break;\n        }\n\n        if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n          break;\n        }\n      } while (scope = scope.parent);\n    }\n  }, {\n    key: \"getAttachmentPath\",\n    value: function getAttachmentPath() {\n      var path = this._getAttachmentPath();\n\n      if (!path) return;\n      var targetScope = path.scope;\n\n      if (targetScope.path === path) {\n        targetScope = path.scope.parent;\n      }\n\n      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n        for (var _i2 = 0, _Object$keys2 = Object.keys(this.bindings); _i2 < _Object$keys2.length; _i2++) {\n          var name = _Object$keys2[_i2];\n          if (!targetScope.hasOwnBinding(name)) continue;\n          var binding = this.bindings[name];\n\n          if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n            continue;\n          }\n\n          var bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n          if (bindingParentPath.key >= path.key) {\n            this.attachAfter = true;\n            path = binding.path;\n\n            var _iterator2 = _createForOfIteratorHelper(binding.constantViolations),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var violationPath = _step2.value;\n\n                if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n                  path = violationPath;\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n        }\n      }\n\n      return path;\n    }\n  }, {\n    key: \"_getAttachmentPath\",\n    value: function _getAttachmentPath() {\n      var scopes = this.scopes;\n      var scope = scopes.pop();\n      if (!scope) return;\n\n      if (scope.path.isFunction()) {\n        if (this.hasOwnParamBindings(scope)) {\n          if (this.scope === scope) return;\n          var bodies = scope.path.get(\"body\").get(\"body\");\n\n          for (var i = 0; i < bodies.length; i++) {\n            if (bodies[i].node._blockHoist) continue;\n            return bodies[i];\n          }\n        } else {\n          return this.getNextScopeAttachmentParent();\n        }\n      } else if (scope.path.isProgram()) {\n        return this.getNextScopeAttachmentParent();\n      }\n    }\n  }, {\n    key: \"getNextScopeAttachmentParent\",\n    value: function getNextScopeAttachmentParent() {\n      var scope = this.scopes.pop();\n      if (scope) return this.getAttachmentParentForPath(scope.path);\n    }\n  }, {\n    key: \"getAttachmentParentForPath\",\n    value: function getAttachmentParentForPath(path) {\n      do {\n        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n          return path;\n        }\n      } while (path = path.parentPath);\n    }\n  }, {\n    key: \"hasOwnParamBindings\",\n    value: function hasOwnParamBindings(scope) {\n      for (var _i3 = 0, _Object$keys3 = Object.keys(this.bindings); _i3 < _Object$keys3.length; _i3++) {\n        var name = _Object$keys3[_i3];\n        if (!scope.hasOwnBinding(name)) continue;\n        var binding = this.bindings[name];\n        if (binding.kind === \"param\" && binding.constant) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"run\",\n    value: function run() {\n      this.path.traverse(referenceVisitor, this);\n      if (this.mutableBinding) return;\n      this.getCompatibleScopes();\n      var attachTo = this.getAttachmentPath();\n      if (!attachTo) return;\n      if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n      var uid = attachTo.scope.generateUidIdentifier(\"ref\");\n      var declarator = t.variableDeclarator(uid, this.path.node);\n      var insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n\n      var _attachTo$insertFn = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]),\n          _attachTo$insertFn2 = _slicedToArray(_attachTo$insertFn, 1),\n          attached = _attachTo$insertFn2[0];\n\n      var parent = this.path.parentPath;\n\n      if (parent.isJSXElement() && this.path.container === parent.node.children) {\n        uid = t.jsxExpressionContainer(uid);\n      }\n\n      this.path.replaceWith(t.cloneNode(uid));\n      return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n    }\n  }]);\n\n  return PathHoister;\n}();\n\nexports.default = PathHoister;","map":null,"metadata":{},"sourceType":"script"}