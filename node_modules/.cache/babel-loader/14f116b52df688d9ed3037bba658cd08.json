{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.get = get;\nexports.minVersion = minVersion;\nexports.getDependencies = getDependencies;\nexports.ensure = ensure;\nexports.default = exports.list = void 0;\n\nvar _traverse = require(\"@babel/traverse\");\n\nvar t = require(\"@babel/types\");\n\nvar _helpers = require(\"./helpers\");\n\nfunction makePath(path) {\n  var parts = [];\n\n  for (; path.parentPath; path = path.parentPath) {\n    parts.push(path.key);\n    if (path.inList) parts.push(path.listKey);\n  }\n\n  return parts.reverse().join(\".\");\n}\n\nvar fileClass = undefined;\n\nfunction getHelperMetadata(file) {\n  var globals = new Set();\n  var localBindingNames = new Set();\n  var dependencies = new Map();\n  var exportName;\n  var exportPath;\n  var exportBindingAssignments = [];\n  var importPaths = [];\n  var importBindingsReferences = [];\n  var dependencyVisitor = {\n    ImportDeclaration: function ImportDeclaration(child) {\n      var name = child.node.source.value;\n\n      if (!_helpers.default[name]) {\n        throw child.buildCodeFrameError(\"Unknown helper \".concat(name));\n      }\n\n      if (child.get(\"specifiers\").length !== 1 || !child.get(\"specifiers.0\").isImportDefaultSpecifier()) {\n        throw child.buildCodeFrameError(\"Helpers can only import a default value\");\n      }\n\n      var bindingIdentifier = child.node.specifiers[0].local;\n      dependencies.set(bindingIdentifier, name);\n      importPaths.push(makePath(child));\n    },\n    ExportDefaultDeclaration: function ExportDefaultDeclaration(child) {\n      var decl = child.get(\"declaration\");\n\n      if (decl.isFunctionDeclaration()) {\n        if (!decl.node.id) {\n          throw decl.buildCodeFrameError(\"Helpers should give names to their exported func declaration\");\n        }\n\n        exportName = decl.node.id.name;\n      }\n\n      exportPath = makePath(child);\n    },\n    ExportAllDeclaration: function ExportAllDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n    ExportNamedDeclaration: function ExportNamedDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n    Statement: function Statement(child) {\n      if (child.isModuleDeclaration()) return;\n      child.skip();\n    }\n  };\n  var referenceVisitor = {\n    Program: function Program(path) {\n      var bindings = path.scope.getAllBindings();\n      Object.keys(bindings).forEach(function (name) {\n        if (name === exportName) return;\n        if (dependencies.has(bindings[name].identifier)) return;\n        localBindingNames.add(name);\n      });\n    },\n    ReferencedIdentifier: function ReferencedIdentifier(child) {\n      var name = child.node.name;\n      var binding = child.scope.getBinding(name, true);\n\n      if (!binding) {\n        globals.add(name);\n      } else if (dependencies.has(binding.identifier)) {\n        importBindingsReferences.push(makePath(child));\n      }\n    },\n    AssignmentExpression: function AssignmentExpression(child) {\n      var left = child.get(\"left\");\n      if (!(exportName in left.getBindingIdentifiers())) return;\n\n      if (!left.isIdentifier()) {\n        throw left.buildCodeFrameError(\"Only simple assignments to exports are allowed in helpers\");\n      }\n\n      var binding = child.scope.getBinding(exportName);\n\n      if (binding != null && binding.scope.path.isProgram()) {\n        exportBindingAssignments.push(makePath(child));\n      }\n    }\n  };\n  (0, _traverse.default)(file.ast, dependencyVisitor, file.scope);\n  (0, _traverse.default)(file.ast, referenceVisitor, file.scope);\n  if (!exportPath) throw new Error(\"Helpers must default-export something.\");\n  exportBindingAssignments.reverse();\n  return {\n    globals: Array.from(globals),\n    localBindingNames: Array.from(localBindingNames),\n    dependencies: dependencies,\n    exportBindingAssignments: exportBindingAssignments,\n    exportPath: exportPath,\n    exportName: exportName,\n    importBindingsReferences: importBindingsReferences,\n    importPaths: importPaths\n  };\n}\n\nfunction permuteHelperAST(file, metadata, id, localBindings, getDependency) {\n  if (localBindings && !id) {\n    throw new Error(\"Unexpected local bindings for module-based helpers.\");\n  }\n\n  if (!id) return;\n  var localBindingNames = metadata.localBindingNames,\n      dependencies = metadata.dependencies,\n      exportBindingAssignments = metadata.exportBindingAssignments,\n      exportPath = metadata.exportPath,\n      exportName = metadata.exportName,\n      importBindingsReferences = metadata.importBindingsReferences,\n      importPaths = metadata.importPaths;\n  var dependenciesRefs = {};\n  dependencies.forEach(function (name, id) {\n    dependenciesRefs[id.name] = typeof getDependency === \"function\" && getDependency(name) || id;\n  });\n  var toRename = {};\n  var bindings = new Set(localBindings || []);\n  localBindingNames.forEach(function (name) {\n    var newName = name;\n\n    while (bindings.has(newName)) {\n      newName = \"_\" + newName;\n    }\n\n    if (newName !== name) toRename[name] = newName;\n  });\n\n  if (id.type === \"Identifier\" && exportName !== id.name) {\n    toRename[exportName] = id.name;\n  }\n\n  var visitor = {\n    Program: function Program(path) {\n      var exp = path.get(exportPath);\n      var imps = importPaths.map(function (p) {\n        return path.get(p);\n      });\n      var impsBindingRefs = importBindingsReferences.map(function (p) {\n        return path.get(p);\n      });\n      var decl = exp.get(\"declaration\");\n\n      if (id.type === \"Identifier\") {\n        if (decl.isFunctionDeclaration()) {\n          exp.replaceWith(decl);\n        } else {\n          exp.replaceWith(t.variableDeclaration(\"var\", [t.variableDeclarator(id, decl.node)]));\n        }\n      } else if (id.type === \"MemberExpression\") {\n        if (decl.isFunctionDeclaration()) {\n          exportBindingAssignments.forEach(function (assignPath) {\n            var assign = path.get(assignPath);\n            assign.replaceWith(t.assignmentExpression(\"=\", id, assign.node));\n          });\n          exp.replaceWith(decl);\n          path.pushContainer(\"body\", t.expressionStatement(t.assignmentExpression(\"=\", id, t.identifier(exportName))));\n        } else {\n          exp.replaceWith(t.expressionStatement(t.assignmentExpression(\"=\", id, decl.node)));\n        }\n      } else {\n        throw new Error(\"Unexpected helper format.\");\n      }\n\n      Object.keys(toRename).forEach(function (name) {\n        path.scope.rename(name, toRename[name]);\n      });\n\n      var _iterator = _createForOfIteratorHelper(imps),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _path = _step.value;\n\n          _path.remove();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(impsBindingRefs),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _path2 = _step2.value;\n          var node = t.cloneNode(dependenciesRefs[_path2.node.name]);\n\n          _path2.replaceWith(node);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      path.stop();\n    }\n  };\n  (0, _traverse.default)(file.ast, visitor, file.scope);\n}\n\nvar helperData = Object.create(null);\n\nfunction loadHelper(name) {\n  if (!helperData[name]) {\n    var helper = _helpers.default[name];\n\n    if (!helper) {\n      throw Object.assign(new ReferenceError(\"Unknown helper \".concat(name)), {\n        code: \"BABEL_HELPER_UNKNOWN\",\n        helper: name\n      });\n    }\n\n    var fn = function fn() {\n      var file = {\n        ast: t.file(helper.ast())\n      };\n\n      if (fileClass) {\n        return new fileClass({\n          filename: \"babel-helper://\".concat(name)\n        }, file);\n      }\n\n      return file;\n    };\n\n    var metadata = getHelperMetadata(fn());\n    helperData[name] = {\n      build: function build(getDependency, id, localBindings) {\n        var file = fn();\n        permuteHelperAST(file, metadata, id, localBindings, getDependency);\n        return {\n          nodes: file.ast.program.body,\n          globals: metadata.globals\n        };\n      },\n      minVersion: function minVersion() {\n        return helper.minVersion;\n      },\n      dependencies: metadata.dependencies\n    };\n  }\n\n  return helperData[name];\n}\n\nfunction get(name, getDependency, id, localBindings) {\n  return loadHelper(name).build(getDependency, id, localBindings);\n}\n\nfunction minVersion(name) {\n  return loadHelper(name).minVersion();\n}\n\nfunction getDependencies(name) {\n  return Array.from(loadHelper(name).dependencies.values());\n}\n\nfunction ensure(name, newFileClass) {\n  if (!fileClass) {\n    fileClass = newFileClass;\n  }\n\n  loadHelper(name);\n}\n\nvar list = Object.keys(_helpers.default).map(function (name) {\n  return name.replace(/^_/, \"\");\n}).filter(function (name) {\n  return name !== \"__esModule\";\n});\nexports.list = list;\nvar _default = get;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}