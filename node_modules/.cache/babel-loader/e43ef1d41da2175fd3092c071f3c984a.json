{"ast":null,"code":"/*\nCopyright (c) 2020 Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\nimport traverse from '@babel/traverse';\nimport generate from '@babel/generator';\nimport * as t from '@babel/types';\nimport { parse as babelParse } from '@babel/parser';\nimport { getAstJsxElement, formatAstAndPrint } from './code-generator';\nexport var parse = function parse(code) {\n  return babelParse(code, {\n    sourceType: 'module',\n    plugins: ['jsx', 'flowComments', 'typescript', 'asyncGenerators', 'classProperties', 'classPrivateProperties', 'classPrivateMethods', ['decorators', {\n      decoratorsBeforeExport: true\n    }], 'doExpressions', 'dynamicImport', 'exportDefaultFrom', 'exportNamespaceFrom', 'functionBind', 'functionSent', 'importMeta', 'logicalAssignment', 'nullishCoalescingOperator', 'numericSeparator', 'objectRestSpread', 'optionalCatchBinding', 'optionalChaining', 'partialApplication', 'throwExpressions', 'topLevelAwait']\n  });\n}; // creates a call expression that synchronizes view state\n\nvar getInstrumentOnChange = function getInstrumentOnChange(what, into) {\n  return t.callExpression(t.identifier('__reactViewOnChange'), [t.identifier(what), t.stringLiteral(into)]);\n}; // appends a call expression to a function body\n\n\nvar fnBodyAppend = function fnBodyAppend(path, callExpression) {\n  if (path.node.type !== 'JSXExpressionContainer') {\n    return;\n  }\n\n  var callbackBody = path.get('expression').get('body');\n\n  if (callbackBody.type === 'BlockStatement') {\n    // when the callback body is a block\n    // e.g.: e => { setValue(e.target.value) }\n    callbackBody.pushContainer('body', callExpression);\n  } else {\n    // when it is a single statement like e => setValue(e.target.value)\n    // we have to create a BlockStatement first\n    callbackBody.replaceWith(t.blockStatement([t.expressionStatement(callbackBody.node), t.expressionStatement(callExpression)]));\n  }\n}; // removing all imports, exports and top level\n// variable declaration, add __reactViewOnChange instrumentation when needed\n\n\nexport var transformBeforeCompilation = function transformBeforeCompilation(ast, elementName, propsConfig) {\n  try {\n    traverse(ast, {\n      VariableDeclaration: function VariableDeclaration(path) {\n        if (path.parent.type === 'Program') {\n          //@ts-ignore\n          path.replaceWith(path.node.declarations[0].init);\n        }\n      },\n      ImportDeclaration: function ImportDeclaration(path) {\n        path.remove();\n      },\n      ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {\n        if (path.node.declaration.type === 'ArrowFunctionExpression' || path.node.declaration.type === 'FunctionDeclaration') {\n          path.replaceWith(path.node.declaration);\n        } else {\n          path.remove();\n        }\n      },\n      // adds internal state instrumentation through __reactViewOnChange callback\n      JSXElement: function JSXElement(path) {\n        if (path.node.openingElement.type === 'JSXOpeningElement' && //@ts-ignore\n        path.node.openingElement.name.name === elementName) {\n          if (propsConfig['children'] && propsConfig['children'].propHook) {\n            var propHook = propsConfig['children'].propHook;\n            path.get('children').forEach(function (child) {\n              typeof propHook === 'object' ? fnBodyAppend(child, getInstrumentOnChange(propHook.what, propHook.into)) : child.traverse(propHook({\n                getInstrumentOnChange: getInstrumentOnChange,\n                fnBodyAppend: fnBodyAppend\n              }));\n            });\n          }\n\n          path.get('openingElement').get('attributes').forEach(function (attr) {\n            var name = attr.get('name').node.name;\n            var propHook = propsConfig[name].propHook;\n\n            if (typeof propHook !== 'undefined') {\n              typeof propHook === 'object' ? fnBodyAppend(attr.get('value'), getInstrumentOnChange(propHook.what, propHook.into)) : attr.traverse(propHook({\n                getInstrumentOnChange: getInstrumentOnChange,\n                fnBodyAppend: fnBodyAppend\n              }));\n            }\n          });\n        }\n      }\n    });\n  } catch (e) {}\n\n  return ast;\n};\nexport function parseCode(code, elementName, parseProvider) {\n  var propValues = {};\n  var stateValues = {};\n  var parsedProvider = undefined;\n\n  try {\n    var ast = parse(code);\n    traverse(ast, {\n      JSXElement: function JSXElement(path) {\n        if (Object.keys(propValues).length === 0 && // process just the first element\n        path.node.openingElement.type === 'JSXOpeningElement' && //@ts-ignore\n        path.node.openingElement.name.name === elementName) {\n          path.node.openingElement.attributes.forEach(function (attr) {\n            var name = attr.name.name;\n            var value = null;\n\n            if (attr.value === null) {\n              //boolean prop without value\n              value = true;\n            } else {\n              if (attr.value.type === 'StringLiteral') {\n                value = attr.value.value;\n              } else if (attr.value.type === 'JSXExpressionContainer') {\n                if (attr.value.expression.type === 'BooleanLiteral') {\n                  value = attr.value.expression.value;\n                } else {\n                  value = formatAstAndPrint( //@ts-ignore\n                  t.program([t.expressionStatement(attr.value.expression)]), 30);\n\n                  if (attr.value.expression.type === 'ObjectExpression') {\n                    // the generated code is ({ .... }), this removes the brackets to\n                    // keep the input more readable\n                    value = value.slice(1, -1);\n                  }\n\n                  if (attr.value.expression.type === 'MemberExpression' && attr.value.expression.computed) {\n                    // turn a['hello-world'] into a.hello-world so we don't have to deal with two\n                    // variants in the enum knob UI\n                    value = \"\".concat(attr.value.expression.object.name, \".\").concat(attr.value.expression.property.value);\n                  }\n                }\n              }\n            }\n\n            propValues[name] = value;\n          });\n          propValues['children'] = formatAstAndPrint(getAstJsxElement('ViewRoot', [], path.node.children), 30).replace(/\\n  /g, '\\n').replace(/^<ViewRoot>\\n?/, '').replace(/<\\/ViewRoot>$/, '').replace(/\\s*<ViewRoot \\/>\\s*/, '');\n        }\n      },\n      VariableDeclarator: function VariableDeclarator(path) {\n        // looking for React.useState()\n        var node = path.node;\n\n        if (node.id.type === 'ArrayPattern' && node.init.type === 'CallExpression' && node.init.callee.property.name === 'useState') {\n          var name = node.id.elements[0].name;\n          var valueNode = node.init.arguments[0];\n\n          if (valueNode.type === 'StringLiteral' || valueNode.type === 'BooleanLiteral') {\n            stateValues[name] = valueNode.value;\n          } else {\n            stateValues[name] = generate(valueNode).code;\n          }\n        }\n      }\n    });\n\n    if (parseProvider) {\n      parsedProvider = parseProvider(ast);\n    }\n  } catch (e) {\n    throw new Error(\"Code is not valid and can't be parsed.\");\n  } // override props by local state (React hooks)\n\n\n  Object.keys(stateValues).forEach(function (stateValueKey) {\n    Object.keys(propValues).forEach(function (propValueKey) {\n      if (propValues[propValueKey] === stateValueKey) {\n        propValues[propValueKey] = stateValues[stateValueKey];\n      }\n    });\n  });\n  return {\n    parsedProps: propValues,\n    parsedProvider: parsedProvider\n  };\n}","map":null,"metadata":{},"sourceType":"module"}