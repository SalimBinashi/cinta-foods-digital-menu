{"ast":null,"code":"import _toConsumableArray from \"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n/*\nCopyright (c) 2020 Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\n\n\nimport template from '@babel/template';\nimport * as t from '@babel/types';\nimport { clone } from './utils';\nimport { PropTypes } from './const';\nimport { parse } from './ast'; // forked prettier on a diet\n//@ts-ignore\n\nimport prettier from '@miksu/prettier/lib/standalone'; //@ts-ignore\n\nimport parsers from '@miksu/prettier/lib/language-js/parser-babylon';\nvar reactImport = template.ast(\"import * as React from 'react';\");\nexport var getAstPropValue = function getAstPropValue(prop, name, customProps) {\n  var value = prop.value;\n\n  switch (prop.type) {\n    case PropTypes.String:\n      return t.stringLiteral(String(value));\n\n    case PropTypes.Boolean:\n      return t.booleanLiteral(Boolean(value));\n\n    case PropTypes.Enum:\n      if (!value) {\n        return t.identifier(String(value));\n      }\n\n      if (!prop.imports) {\n        return t.stringLiteral(String(value));\n      }\n\n      var _String$split = String(value).split('.'),\n          _String$split2 = _slicedToArray(_String$split, 2),\n          object = _String$split2[0],\n          property = _String$split2[1];\n\n      return t.memberExpression(t.identifier(object), property.includes('-') ? t.stringLiteral(property) : t.identifier(property), property.includes('-') ? true : false);\n\n    case PropTypes.Date:\n      return t.newExpression(t.identifier('Date'), value ? [t.stringLiteral(String(value))] : []);\n\n    case PropTypes.Ref:\n      return null;\n\n    case PropTypes.Object:\n      // need to add this bogus assignment so the value is recognized as an ObjectExpression\n      return template.ast(\"a = \".concat(value), {\n        plugins: ['jsx']\n      }).expression.right;\n\n    case PropTypes.Array:\n    case PropTypes.Number:\n    case PropTypes.Function:\n    case PropTypes.ReactNode:\n      var output = template.ast(String(value), {\n        plugins: ['jsx']\n      }).expression; // we never expect that user would input a variable as the value\n      // treat it as a string instead\n\n      if (output.type === 'Identifier') {\n        return t.stringLiteral(output.name);\n      }\n\n      return output;\n\n    case PropTypes.Custom:\n      if (!customProps[name] || !customProps[name].generate) {\n        console.error(\"Missing customProps.\".concat(name, \".generate definition.\"));\n      }\n\n      return customProps[name].generate(value);\n  }\n};\nexport var getAstPropsArray = function getAstPropsArray(props, customProps) {\n  return Object.entries(props).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0],\n        prop = _ref2[1];\n\n    var value = prop.value,\n        stateful = prop.stateful,\n        defaultValue = prop.defaultValue;\n    if (stateful) return t.jsxAttribute(t.jsxIdentifier(name), t.jsxExpressionContainer(t.identifier(name))); // When the `defaultValue` is set and `value` is the same as the `defaultValue`\n    // we don't add it to the list of props.\n    // It handles boolean props where `defaultValue` set to true,\n    // and enum props that have a `defaultValue` set to be displayed\n    // in the view correctly (checked checkboxes and selected default value in radio groups)\n    // and not rendered in the component's props.\n\n    if (typeof value !== 'boolean' && typeof value !== 'number' && !value || value === defaultValue || typeof value === 'boolean' && !value && !defaultValue) {\n      return null;\n    }\n\n    var astValue = getAstPropValue(prop, name, customProps);\n    if (!astValue) return null; // shortcut render \"isDisabled\" vs \"isDisabled={true}\"\n\n    if (astValue.type === 'BooleanLiteral' && astValue.value === true) {\n      return t.jsxAttribute(t.jsxIdentifier(name), null);\n    }\n\n    return t.jsxAttribute(t.jsxIdentifier(name), astValue.type === 'StringLiteral' ? astValue : t.jsxExpressionContainer(astValue));\n  });\n};\nexport var getAstReactHooks = function getAstReactHooks(props, customProps) {\n  var hooks = [];\n  var buildReactHook = template(\"const [%%name%%, %%setName%%] = React.useState(%%value%%);\");\n  Object.keys(props).forEach(function (name) {\n    if (props[name].stateful === true) {\n      hooks.push(buildReactHook({\n        name: t.identifier(name),\n        setName: t.identifier(\"set\".concat(name[0].toUpperCase() + name.slice(1))),\n        value: getAstPropValue(props[name], name, customProps)\n      }));\n    }\n  });\n  return hooks;\n};\nexport var getAstImport = function getAstImport(identifiers, source, defaultIdentifier) {\n  return t.importDeclaration([].concat(_toConsumableArray(defaultIdentifier ? [t.importDefaultSpecifier(t.identifier(defaultIdentifier))] : []), _toConsumableArray(identifiers.map(function (identifier) {\n    return t.importSpecifier(t.identifier(identifier), t.identifier(identifier));\n  }))), t.stringLiteral(source));\n};\nexport var getAstJsxElement = function getAstJsxElement(name, attrs, children) {\n  var isSelfClosing = children.length === 0;\n  return t.jsxElement(t.jsxOpeningElement(t.jsxIdentifier(name), attrs.filter(function (attr) {\n    return !!attr;\n  }), isSelfClosing), isSelfClosing ? null : t.jsxClosingElement(t.jsxIdentifier(name)), children, true);\n};\nexport var addToImportList = function addToImportList(importList, imports) {\n  for (var _i = 0, _Object$entries = Object.entries(imports); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        importFrom = _Object$entries$_i[0],\n        importNames = _Object$entries$_i[1];\n\n    if (!importList.hasOwnProperty(importFrom)) {\n      importList[importFrom] = {\n        named: [],\n        default: ''\n      };\n    }\n\n    if (importNames.default) {\n      importList[importFrom].default = importNames.default;\n    }\n\n    if (importNames.named && importNames.named.length > 0) {\n      if (!importList[importFrom].hasOwnProperty('named')) {\n        importList[importFrom]['named'] = [];\n      }\n\n      importList[importFrom].named = _toConsumableArray(new Set(importList[importFrom].named.concat(importNames.named)));\n    }\n  }\n};\nexport var getAstImports = function getAstImports(importsConfig, providerImports, props) {\n  // global scoped import that are always displayed\n  var importList = clone(importsConfig); // prop level imports (typically enums related) that are displayed\n  // only when the prop is being used\n\n  Object.values(props).forEach(function (prop) {\n    if (prop.imports && prop.value && prop.value !== '' && prop.value !== prop.defaultValue) {\n      addToImportList(importList, prop.imports);\n    }\n  });\n  addToImportList(importList, providerImports);\n  return Object.keys(importList).map(function (from) {\n    return getAstImport(importList[from].named || [], from, importList[from].default);\n  });\n};\n\nvar getChildrenAst = function getChildrenAst(value) {\n  return template.ast(\"<>\".concat(value, \"</>\"), {\n    plugins: ['jsx']\n  }).expression.children;\n};\n\nexport var getAst = function getAst(props, componentName, provider, providerValue, importsConfig, customProps) {\n  var children = props.children,\n      restProps = __rest(props, [\"children\"]);\n\n  var buildExport = template(\"export default () => {%%body%%}\");\n  return t.file(t.program([reactImport].concat(_toConsumableArray(getAstImports(importsConfig, providerValue ? provider.imports : {}, props)), [buildExport({\n    body: [].concat(_toConsumableArray(getAstReactHooks(restProps, customProps)), [t.returnStatement(provider.generate(providerValue, getAstJsxElement(componentName, getAstPropsArray(restProps, customProps), children && children.value ? getChildrenAst(String(children.value)) : [])))])\n  })])), [], []);\n};\nexport var formatAstAndPrint = function formatAstAndPrint(ast, printWidth) {\n  var result = prettier.__debug.formatAST(ast, {\n    originalText: '',\n    parser: 'babel',\n    printWidth: printWidth ? printWidth : 58,\n    plugins: [parsers]\n  });\n\n  return result.formatted // add a new line before export\n  .replace('export default', \"\".concat(result.formatted.startsWith('import ') ? '\\n' : '', \"export default\")) // remove newline at the end of file\n  .replace(/[\\r\\n]+$/, '') // remove ; at the end of file\n  .replace(/[;]+$/, '');\n};\nexport var formatCode = function formatCode(code) {\n  return formatAstAndPrint(parse(code));\n};\nexport var getCode = function getCode(_ref3) {\n  var props = _ref3.props,\n      componentName = _ref3.componentName,\n      provider = _ref3.provider,\n      providerValue = _ref3.providerValue,\n      importsConfig = _ref3.importsConfig,\n      customProps = _ref3.customProps;\n\n  if (Object.keys(props).length === 0) {\n    return '';\n  }\n\n  var ast = getAst(props, componentName, provider, providerValue, importsConfig, customProps);\n  return formatAstAndPrint(ast);\n};","map":null,"metadata":{},"sourceType":"module"}