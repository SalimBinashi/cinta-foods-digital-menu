{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar t = require('@babel/types');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function get() {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar t__namespace = /*#__PURE__*/_interopNamespace(t);\n\nfunction willPathCastToBoolean(path) {\n  var maybeWrapped = path;\n  var node = maybeWrapped.node,\n      parentPath = maybeWrapped.parentPath;\n\n  if (parentPath.isLogicalExpression()) {\n    var _parentPath$node = parentPath.node,\n        operator = _parentPath$node.operator,\n        right = _parentPath$node.right;\n\n    if (operator === \"&&\" || operator === \"||\" || operator === \"??\" && node === right) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n\n  if (parentPath.isSequenceExpression()) {\n    var expressions = parentPath.node.expressions;\n\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      return true;\n    }\n  }\n\n  return parentPath.isConditional({\n    test: node\n  }) || parentPath.isUnaryExpression({\n    operator: \"!\"\n  }) || parentPath.isLoop({\n    test: node\n  });\n}\n\nvar AssignmentMemoiser = /*#__PURE__*/function () {\n  function AssignmentMemoiser() {\n    _classCallCheck(this, AssignmentMemoiser);\n\n    this._map = void 0;\n    this._map = new WeakMap();\n  }\n\n  _createClass(AssignmentMemoiser, [{\n    key: \"has\",\n    value: function has(key) {\n      return this._map.has(key);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      if (!this.has(key)) return;\n\n      var record = this._map.get(key);\n\n      var value = record.value;\n      record.count--;\n\n      if (record.count === 0) {\n        return t__namespace.assignmentExpression(\"=\", value, key);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value, count) {\n      return this._map.set(key, {\n        count: count,\n        value: value\n      });\n    }\n  }]);\n\n  return AssignmentMemoiser;\n}();\n\nfunction toNonOptional(path, base) {\n  var node = path.node;\n\n  if (t__namespace.isOptionalMemberExpression(node)) {\n    return t__namespace.memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    var callee = path.get(\"callee\");\n\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      var object = callee.node.object;\n      var context = path.scope.maybeGenerateMemoised(object) || object;\n      callee.get(\"object\").replaceWith(t__namespace.assignmentExpression(\"=\", context, object));\n      return t__namespace.callExpression(t__namespace.memberExpression(base, t__namespace.identifier(\"call\")), [context].concat(_toConsumableArray(path.node.arguments)));\n    }\n\n    return t__namespace.callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n    var _path = path,\n        parentPath = _path.parentPath,\n        container = _path.container,\n        listKey = _path.listKey;\n    var parentNode = parentPath.node;\n\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nvar handle = {\n  memoise: function memoise() {},\n  handle: function handle(member, noDocumentAll) {\n    var node = member.node,\n        parent = member.parent,\n        parentPath = member.parentPath,\n        scope = member.scope;\n\n    if (member.isOptionalMemberExpression()) {\n      if (isInDetachedTree(member)) return;\n      var endPath = member.find(function (_ref) {\n        var node = _ref.node,\n            parent = _ref.parent;\n\n        if (t__namespace.isOptionalMemberExpression(parent)) {\n          return parent.optional || parent.object !== node;\n        }\n\n        if (t__namespace.isOptionalCallExpression(parent)) {\n          return node !== member.node && parent.optional || parent.callee !== node;\n        }\n\n        return true;\n      });\n\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(t__namespace.callExpression(t__namespace.arrowFunctionExpression([], endPath.node), []));\n        return;\n      }\n\n      var willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n      var rootParentPath = endPath.parentPath;\n\n      if (rootParentPath.isUpdateExpression({\n        argument: node\n      }) || rootParentPath.isAssignmentExpression({\n        left: node\n      })) {\n        throw member.buildCodeFrameError(\"can't handle assignment\");\n      }\n\n      var isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\"\n      });\n\n      if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get(\"property\").isPrivateName()) {\n        throw member.buildCodeFrameError(\"can't delete a private class element\");\n      }\n\n      var startingOptional = member;\n\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n\n        throw new Error(\"Internal error: unexpected \".concat(startingOptional.node.type));\n      }\n\n      var startingProp = startingOptional.isOptionalMemberExpression() ? \"object\" : \"callee\";\n      var startingNode = startingOptional.node[startingProp];\n      var baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      var baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;\n      var parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node\n      });\n\n      var isOptionalCall = function isOptionalCall(parent) {\n        return parentIsOptionalCall;\n      };\n\n      var parentIsCall = parentPath.isCallExpression({\n        callee: node\n      });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n\n      if (isOptionalCall()) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      var regular = member.node;\n\n      for (var current = member; current !== endPath;) {\n        var _parentPath = current.parentPath;\n\n        if (_parentPath === endPath && isOptionalCall() && parent.optional) {\n          regular = _parentPath.node;\n          break;\n        }\n\n        regular = toNonOptional(_parentPath, regular);\n        current = _parentPath;\n      }\n\n      var context;\n      var endParentPath = endPath.parentPath;\n\n      if (t__namespace.isMemberExpression(regular) && endParentPath.isOptionalCallExpression({\n        callee: endPath.node,\n        optional: true\n      })) {\n        var _regular = regular,\n            object = _regular.object;\n        context = member.scope.maybeGenerateMemoised(object);\n\n        if (context) {\n          regular.object = t__namespace.assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      var replacementPath = endPath;\n\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      var baseMemoised = baseNeedsMemoised ? t__namespace.assignmentExpression(\"=\", t__namespace.cloneNode(baseRef), t__namespace.cloneNode(startingNode)) : t__namespace.cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        var nonNullishCheck;\n\n        if (noDocumentAll) {\n          nonNullishCheck = t__namespace.binaryExpression(\"!=\", baseMemoised, t__namespace.nullLiteral());\n        } else {\n          nonNullishCheck = t__namespace.logicalExpression(\"&&\", t__namespace.binaryExpression(\"!==\", baseMemoised, t__namespace.nullLiteral()), t__namespace.binaryExpression(\"!==\", t__namespace.cloneNode(baseRef), scope.buildUndefinedNode()));\n        }\n\n        replacementPath.replaceWith(t__namespace.logicalExpression(\"&&\", nonNullishCheck, regular));\n      } else {\n        var nullishCheck;\n\n        if (noDocumentAll) {\n          nullishCheck = t__namespace.binaryExpression(\"==\", baseMemoised, t__namespace.nullLiteral());\n        } else {\n          nullishCheck = t__namespace.logicalExpression(\"||\", t__namespace.binaryExpression(\"===\", baseMemoised, t__namespace.nullLiteral()), t__namespace.binaryExpression(\"===\", t__namespace.cloneNode(baseRef), scope.buildUndefinedNode()));\n        }\n\n        replacementPath.replaceWith(t__namespace.conditionalExpression(nullishCheck, isDeleteOperation ? t__namespace.booleanLiteral(true) : scope.buildUndefinedNode(), regular));\n      }\n\n      if (context) {\n        var endParent = endParentPath.node;\n        endParentPath.replaceWith(t__namespace.optionalCallExpression(t__namespace.optionalMemberExpression(endParent.callee, t__namespace.identifier(\"call\"), false, true), [t__namespace.cloneNode(context)].concat(_toConsumableArray(endParent.arguments)), false));\n      }\n\n      return;\n    }\n\n    if (t__namespace.isUpdateExpression(parent, {\n      argument: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      var operator = parent.operator,\n          prefix = parent.prefix;\n      this.memoise(member, 2);\n      var value = t__namespace.binaryExpression(operator[0], t__namespace.unaryExpression(\"+\", this.get(member)), t__namespace.numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        var _scope = member.scope;\n\n        var ref = _scope.generateUidIdentifierBasedOnNode(node);\n\n        _scope.push({\n          id: ref\n        });\n\n        value.left = t__namespace.assignmentExpression(\"=\", t__namespace.cloneNode(ref), value.left);\n        parentPath.replaceWith(t__namespace.sequenceExpression([this.set(member, value), t__namespace.cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      var _parentPath$node2 = parentPath.node,\n          _operator = _parentPath$node2.operator,\n          _value = _parentPath$node2.right;\n\n      if (_operator === \"=\") {\n        parentPath.replaceWith(this.set(member, _value));\n      } else {\n        var operatorTrunc = _operator.slice(0, -1);\n\n        if (t__namespace.LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          this.memoise(member, 1);\n          parentPath.replaceWith(t__namespace.logicalExpression(operatorTrunc, this.get(member), this.set(member, _value)));\n        } else {\n          this.memoise(member, 2);\n          parentPath.replaceWith(this.set(member, t__namespace.binaryExpression(operatorTrunc, this.get(member), _value)));\n        }\n      }\n\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    if (parentPath.isOptionalCallExpression({\n      callee: node\n    })) {\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(t__namespace.callExpression(t__namespace.arrowFunctionExpression([], parentPath.node), []));\n        return;\n      }\n\n      parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments));\n      return;\n    }\n\n    if (parentPath.isForXStatement({\n      left: node\n    }) || parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      member.replaceWith(this.boundGet(member));\n    } else {\n      member.replaceWith(this.get(member));\n    }\n  }\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}\n\nexports.default = memberExpressionToFunctions;","map":null,"metadata":{},"sourceType":"script"}