{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.TSInferType = TSInferType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.Identifier = Identifier;\n\nvar t = require(\"@babel/types\");\n\nvar isArrayTypeAnnotation = t.isArrayTypeAnnotation,\n    isArrowFunctionExpression = t.isArrowFunctionExpression,\n    isAssignmentExpression = t.isAssignmentExpression,\n    isAwaitExpression = t.isAwaitExpression,\n    isBinary = t.isBinary,\n    isBinaryExpression = t.isBinaryExpression,\n    isCallExpression = t.isCallExpression,\n    isClassDeclaration = t.isClassDeclaration,\n    isClassExpression = t.isClassExpression,\n    isConditional = t.isConditional,\n    isConditionalExpression = t.isConditionalExpression,\n    isExportDeclaration = t.isExportDeclaration,\n    isExportDefaultDeclaration = t.isExportDefaultDeclaration,\n    isExpressionStatement = t.isExpressionStatement,\n    isFor = t.isFor,\n    isForInStatement = t.isForInStatement,\n    isForOfStatement = t.isForOfStatement,\n    isForStatement = t.isForStatement,\n    isIfStatement = t.isIfStatement,\n    isIndexedAccessType = t.isIndexedAccessType,\n    isIntersectionTypeAnnotation = t.isIntersectionTypeAnnotation,\n    isLogicalExpression = t.isLogicalExpression,\n    isMemberExpression = t.isMemberExpression,\n    isNewExpression = t.isNewExpression,\n    isNullableTypeAnnotation = t.isNullableTypeAnnotation,\n    isObjectPattern = t.isObjectPattern,\n    isOptionalCallExpression = t.isOptionalCallExpression,\n    isOptionalMemberExpression = t.isOptionalMemberExpression,\n    isReturnStatement = t.isReturnStatement,\n    isSequenceExpression = t.isSequenceExpression,\n    isSwitchStatement = t.isSwitchStatement,\n    isTSArrayType = t.isTSArrayType,\n    isTSAsExpression = t.isTSAsExpression,\n    isTSIntersectionType = t.isTSIntersectionType,\n    isTSNonNullExpression = t.isTSNonNullExpression,\n    isTSOptionalType = t.isTSOptionalType,\n    isTSRestType = t.isTSRestType,\n    isTSTypeAssertion = t.isTSTypeAssertion,\n    isTSUnionType = t.isTSUnionType,\n    isTaggedTemplateExpression = t.isTaggedTemplateExpression,\n    isThrowStatement = t.isThrowStatement,\n    isTypeAnnotation = t.isTypeAnnotation,\n    isUnaryLike = t.isUnaryLike,\n    isUnionTypeAnnotation = t.isUnionTypeAnnotation,\n    isVariableDeclarator = t.isVariableDeclarator,\n    isWhileStatement = t.isWhileStatement,\n    isYieldExpression = t.isYieldExpression;\nvar PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nvar isClassExtendsClause = function isClassExtendsClause(node, parent) {\n  return (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;\n};\n\nvar hasPostfixPart = function hasPostfixPart(node, parent) {\n  return (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\n};\n\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    arrowBody: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, {\n    expressionStatement: true\n  });\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    var parentOp = parent.operator;\n    var parentPos = PRECEDENCE[parentOp];\n    var nodeOp = node.operator;\n    var nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\n\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n    test: node\n  }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent, {\n    callee: node\n  }) || isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent) {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction Identifier(node, parent, printStack) {\n  if (node.name === \"let\") {\n    var isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, {\n      expressionStatement: isFollowedByBracket,\n      forHead: isFollowedByBracket,\n      forInHead: isFollowedByBracket,\n      forOfHead: true\n    });\n  }\n\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\n\nfunction isFirstInContext(printStack, _ref) {\n  var _ref$expressionStatem = _ref.expressionStatement,\n      expressionStatement = _ref$expressionStatem === void 0 ? false : _ref$expressionStatem,\n      _ref$arrowBody = _ref.arrowBody,\n      arrowBody = _ref$arrowBody === void 0 ? false : _ref$arrowBody,\n      _ref$exportDefault = _ref.exportDefault,\n      exportDefault = _ref$exportDefault === void 0 ? false : _ref$exportDefault,\n      _ref$forHead = _ref.forHead,\n      forHead = _ref$forHead === void 0 ? false : _ref$forHead,\n      _ref$forInHead = _ref.forInHead,\n      forInHead = _ref$forInHead === void 0 ? false : _ref$forInHead,\n      _ref$forOfHead = _ref.forOfHead,\n      forOfHead = _ref$forOfHead === void 0 ? false : _ref$forOfHead;\n  var i = printStack.length - 1;\n  var node = printStack[i];\n  i--;\n  var parent = printStack[i];\n\n  while (i >= 0) {\n    if (expressionStatement && isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && isForStatement(parent, {\n      init: node\n    }) || forInHead && isForInStatement(parent, {\n      left: node\n    }) || forOfHead && isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n\n    if (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, {\n      test: node\n    }) || isBinary(parent, {\n      left: node\n    }) || isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"script"}