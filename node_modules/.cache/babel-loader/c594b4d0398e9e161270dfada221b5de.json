{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar path = require(\"path\");\n\nvar ConfigError = require(\"../common/errors\").ConfigError;\n\nvar jsLoc = require(\"../language-js/loc\");\n\nvar locStart = jsLoc.locStart,\n    locEnd = jsLoc.locEnd; // Use defineProperties()/getOwnPropertyDescriptor() to prevent\n// triggering the parsers getters.\n\nvar ownNames = Object.getOwnPropertyNames;\nvar ownDescriptor = Object.getOwnPropertyDescriptor;\n\nfunction getParsers(options) {\n  var parsers = {};\n\n  var _iterator = _createForOfIteratorHelper(options.plugins),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var plugin = _step.value;\n\n      if (!plugin.parsers) {\n        continue;\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(ownNames(plugin.parsers)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var name = _step2.value;\n          Object.defineProperty(parsers, name, ownDescriptor(plugin.parsers, name));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return parsers;\n}\n\nfunction resolveParser(opts, parsers) {\n  parsers = parsers || getParsers(opts);\n\n  if (typeof opts.parser === \"function\") {\n    // Custom parser API always works with JavaScript.\n    return {\n      parse: opts.parser,\n      astFormat: \"estree\",\n      locStart: locStart,\n      locEnd: locEnd\n    };\n  }\n\n  if (typeof opts.parser === \"string\") {\n    if (Object.prototype.hasOwnProperty.call(parsers, opts.parser)) {\n      return parsers[opts.parser];\n    }\n    /* istanbul ignore next */\n\n\n    if (process.env.PRETTIER_TARGET === \"universal\") {\n      throw new ConfigError(\"Couldn't resolve parser \\\"\".concat(opts.parser, \"\\\". Parsers must be explicitly added to the standalone bundle.\"));\n    } else {\n      try {\n        return {\n          parse: eval(\"require\")(path.resolve(process.cwd(), opts.parser)),\n          astFormat: \"estree\",\n          locStart: locStart,\n          locEnd: locEnd\n        };\n      } catch (err) {\n        /* istanbul ignore next */\n        throw new ConfigError(\"Couldn't resolve parser \\\"\".concat(opts.parser, \"\\\"\"));\n      }\n    }\n  }\n}\n\nfunction parse(text, opts) {\n  var parsers = getParsers(opts); // Create a new object {parserName: parseFn}. Uses defineProperty() to only call\n  // the parsers getters when actually calling the parser `parse` function.\n\n  var parsersForCustomParserApi = Object.keys(parsers).reduce(function (object, parserName) {\n    return Object.defineProperty(object, parserName, {\n      enumerable: true,\n      get: function get() {\n        return parsers[parserName].parse;\n      }\n    });\n  }, {});\n  var parser = resolveParser(opts, parsers);\n\n  try {\n    if (parser.preprocess) {\n      text = parser.preprocess(text, opts);\n    }\n\n    return {\n      text: text,\n      ast: parser.parse(text, parsersForCustomParserApi, opts)\n    };\n  } catch (error) {\n    var loc = error.loc;\n\n    if (loc) {\n      var codeFrame = require(\"@babel/code-frame\");\n\n      error.codeFrame = codeFrame.codeFrameColumns(text, loc, {\n        highlightCode: true\n      });\n      error.message += \"\\n\" + error.codeFrame;\n      throw error;\n    }\n    /* istanbul ignore next */\n\n\n    throw error.stack;\n  }\n}\n\nmodule.exports = {\n  parse: parse,\n  resolveParser: resolveParser\n};","map":null,"metadata":{},"sourceType":"script"}