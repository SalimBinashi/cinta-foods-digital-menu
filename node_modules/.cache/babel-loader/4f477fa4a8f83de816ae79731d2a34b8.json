{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createPlugin;\n\nvar _pluginSyntaxJsx = require(\"@babel/plugin-syntax-jsx\");\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nvar DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\"\n};\nvar JSX_SOURCE_ANNOTATION_REGEX = /\\*?\\s*@jsxImportSource\\s+([^\\s]+)/;\nvar JSX_RUNTIME_ANNOTATION_REGEX = /\\*?\\s*@jsxRuntime\\s+([^\\s]+)/;\nvar JSX_ANNOTATION_REGEX = /\\*?\\s*@jsx\\s+([^\\s]+)/;\nvar JSX_FRAG_ANNOTATION_REGEX = /\\*?\\s*@jsxFrag\\s+([^\\s]+)/;\n\nvar get = function get(pass, name) {\n  return pass.get(\"@babel/plugin-react-jsx/\".concat(name));\n};\n\nvar set = function set(pass, name, v) {\n  return pass.set(\"@babel/plugin-react-jsx/\".concat(name), v);\n};\n\nfunction createPlugin(_ref) {\n  var name = _ref.name,\n      development = _ref.development;\n  return (0, _helperPluginUtils.declare)(function (api, options) {\n    var PURE_ANNOTATION = options.pure,\n        _options$throwIfNames = options.throwIfNamespace,\n        throwIfNamespace = _options$throwIfNames === void 0 ? true : _options$throwIfNames,\n        filter = options.filter,\n        _options$runtime = options.runtime,\n        RUNTIME_DEFAULT = _options$runtime === void 0 ? development ? \"automatic\" : \"classic\" : _options$runtime,\n        _options$importSource = options.importSource,\n        IMPORT_SOURCE_DEFAULT = _options$importSource === void 0 ? DEFAULT.importSource : _options$importSource,\n        _options$pragma = options.pragma,\n        PRAGMA_DEFAULT = _options$pragma === void 0 ? DEFAULT.pragma : _options$pragma,\n        _options$pragmaFrag = options.pragmaFrag,\n        PRAGMA_FRAG_DEFAULT = _options$pragmaFrag === void 0 ? DEFAULT.pragmaFrag : _options$pragmaFrag;\n    {\n      var _options$useSpread = options.useSpread,\n          useSpread = _options$useSpread === void 0 ? false : _options$useSpread,\n          _options$useBuiltIns = options.useBuiltIns,\n          useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useSpread (defaults to false)\");\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useBuiltIns (defaults to false)\");\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\"transform-react-jsx currently only accepts useBuiltIns or useSpread \" + \"but not both\");\n        }\n      }\n    }\n    var injectMetaPropertiesVisitor = {\n      JSXOpeningElement: function JSXOpeningElement(path, state) {\n        var _iterator = _createForOfIteratorHelper(path.get(\"attributes\")),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var attr = _step.value;\n            if (!attr.isJSXElement()) continue;\n            var _name = attr.node.name.name;\n\n            if (_name === \"__source\" || _name === \"__self\") {\n              throw path.buildCodeFrameError(\"__source and __self should not be defined in props and are reserved for internal usage.\");\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var attributes = [];\n\n        if (isThisAllowed(path)) {\n          attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__self\"), _core.types.jsxExpressionContainer(_core.types.thisExpression())));\n        }\n\n        attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__source\"), _core.types.jsxExpressionContainer(makeSource(path, state))));\n        path.pushContainer(\"attributes\", attributes);\n      }\n    };\n    return {\n      name: name,\n      inherits: _pluginSyntaxJsx.default,\n      visitor: {\n        JSXNamespacedName: function JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(\"Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.\");\n          }\n        },\n        JSXSpreadChild: function JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\"Spread children are not supported in React.\");\n        },\n        Program: {\n          enter: function enter(path, state) {\n            var file = state.file;\n            var runtime = RUNTIME_DEFAULT;\n            var source = IMPORT_SOURCE_DEFAULT;\n            var pragma = PRAGMA_DEFAULT;\n            var pragmaFrag = PRAGMA_FRAG_DEFAULT;\n            var sourceSet = !!options.importSource;\n            var pragmaSet = !!options.pragma;\n            var pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              var _iterator2 = _createForOfIteratorHelper(file.ast.comments),\n                  _step2;\n\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var comment = _step2.value;\n                  var sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);\n\n                  if (sourceMatches) {\n                    source = sourceMatches[1];\n                    sourceSet = true;\n                  }\n\n                  var runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);\n\n                  if (runtimeMatches) {\n                    runtime = runtimeMatches[1];\n                  }\n\n                  var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n                  if (jsxMatches) {\n                    pragma = jsxMatches[1];\n                    pragmaSet = true;\n                  }\n\n                  var jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n\n                  if (jsxFragMatches) {\n                    pragmaFrag = jsxFragMatches[1];\n                    pragmaFragSet = true;\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(\"importSource cannot be set when runtime is classic.\");\n              }\n\n              var createElement = toMemberExpression(pragma);\n              var fragment = toMemberExpression(pragmaFrag);\n              set(state, \"id/createElement\", function () {\n                return _core.types.cloneNode(createElement);\n              });\n              set(state, \"id/fragment\", function () {\n                return _core.types.cloneNode(fragment);\n              });\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(\"pragma and pragmaFrag cannot be set when runtime is automatic.\");\n              }\n\n              var define = function define(name, id) {\n                return set(state, name, createImportLazily(state, path, id, source));\n              };\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(\"Runtime must be either \\\"classic\\\" or \\\"automatic\\\".\");\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          }\n        },\n        JSXElement: {\n          exit: function exit(path, file) {\n            var callExpr;\n\n            if (get(file, \"runtime\") === \"classic\" || shouldUseCreateElement(path)) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n        },\n        JSXFragment: {\n          exit: function exit(path, file) {\n            var callExpr;\n\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n        },\n        JSXAttribute: function JSXAttribute(path) {\n          if (_core.types.isJSXElement(path.node.value)) {\n            path.node.value = _core.types.jsxExpressionContainer(path.node.value);\n          }\n        }\n      }\n    };\n\n    function getThisFunctionParent(path) {\n      var scope = path.scope;\n\n      do {\n        if (scope.path.isFunctionParent() && !scope.path.isArrowFunctionExpression()) {\n          return scope.path;\n        }\n      } while (scope = scope.parent);\n\n      return null;\n    }\n\n    function isDerivedClass(classPath) {\n      return classPath.node.superClass !== null;\n    }\n\n    function isThisAllowed(path) {\n      var parentMethodOrFunction = getThisFunctionParent(path);\n\n      if (parentMethodOrFunction === null) {\n        return true;\n      }\n\n      if (!parentMethodOrFunction.isMethod()) {\n        return true;\n      }\n\n      if (parentMethodOrFunction.node.kind !== \"constructor\") {\n        return true;\n      }\n\n      return !isDerivedClass(parentMethodOrFunction.parentPath.parentPath);\n    }\n\n    function call(pass, name, args) {\n      var node = _core.types.callExpression(get(pass, \"id/\".concat(name))(), args);\n\n      if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, \"defaultPure\")) (0, _helperAnnotateAsPure.default)(node);\n      return node;\n    }\n\n    function shouldUseCreateElement(path) {\n      var openingPath = path.get(\"openingElement\");\n      var attributes = openingPath.node.attributes;\n      var seenPropsSpread = false;\n\n      for (var i = 0; i < attributes.length; i++) {\n        var attr = attributes[i];\n\n        if (seenPropsSpread && _core.types.isJSXAttribute(attr) && attr.name.name === \"key\") {\n          return true;\n        } else if (_core.types.isJSXSpreadAttribute(attr)) {\n          seenPropsSpread = true;\n        }\n      }\n\n      return false;\n    }\n\n    function convertJSXIdentifier(node, parent) {\n      if (_core.types.isJSXIdentifier(node)) {\n        if (node.name === \"this\" && _core.types.isReferenced(node, parent)) {\n          return _core.types.thisExpression();\n        } else if (_core.types.isValidIdentifier(node.name, false)) {\n          node.type = \"Identifier\";\n        } else {\n          return _core.types.stringLiteral(node.name);\n        }\n      } else if (_core.types.isJSXMemberExpression(node)) {\n        return _core.types.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));\n      } else if (_core.types.isJSXNamespacedName(node)) {\n        return _core.types.stringLiteral(\"\".concat(node.namespace.name, \":\").concat(node.name.name));\n      }\n\n      return node;\n    }\n\n    function convertAttributeValue(node) {\n      if (_core.types.isJSXExpressionContainer(node)) {\n        return node.expression;\n      } else {\n        return node;\n      }\n    }\n\n    function accumulateAttribute(array, attribute) {\n      if (_core.types.isJSXSpreadAttribute(attribute.node)) {\n        var arg = attribute.node.argument;\n\n        if (_core.types.isObjectExpression(arg)) {\n          array.push.apply(array, _toConsumableArray(arg.properties));\n        } else {\n          array.push(_core.types.spreadElement(arg));\n        }\n\n        return array;\n      }\n\n      var value = convertAttributeValue(attribute.node.name.name !== \"key\" ? attribute.node.value || _core.types.booleanLiteral(true) : attribute.node.value);\n\n      if (attribute.node.name.name === \"key\" && value === null) {\n        throw attribute.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n      }\n\n      if (_core.types.isStringLiteral(value) && !_core.types.isJSXExpressionContainer(attribute.node.value)) {\n        var _value$extra;\n\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n        (_value$extra = value.extra) == null ? true : delete _value$extra.raw;\n      }\n\n      if (_core.types.isJSXNamespacedName(attribute.node.name)) {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.namespace.name + \":\" + attribute.node.name.name.name);\n      } else if (_core.types.isValidIdentifier(attribute.node.name.name, false)) {\n        attribute.node.name.type = \"Identifier\";\n      } else {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.name);\n      }\n\n      array.push(_core.types.inherits(_core.types.objectProperty(attribute.node.name, value), attribute.node));\n      return array;\n    }\n\n    function buildChildrenProperty(children) {\n      var childrenNode;\n\n      if (children.length === 1) {\n        childrenNode = children[0];\n      } else if (children.length > 1) {\n        childrenNode = _core.types.arrayExpression(children);\n      } else {\n        return undefined;\n      }\n\n      return _core.types.objectProperty(_core.types.identifier(\"children\"), childrenNode);\n    }\n\n    function buildJSXElementCall(path, file) {\n      var openingPath = path.get(\"openingElement\");\n      var args = [getTag(openingPath)];\n      var attribsArray = [];\n      var extracted = Object.create(null);\n\n      var _iterator3 = _createForOfIteratorHelper(openingPath.get(\"attributes\")),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var attr = _step3.value;\n\n          if (attr.isJSXAttribute() && _core.types.isJSXIdentifier(attr.node.name)) {\n            var _name2 = attr.node.name.name;\n\n            switch (_name2) {\n              case \"__source\":\n              case \"__self\":\n                if (extracted[_name2]) throw sourceSelfError(path, _name2);\n\n              case \"key\":\n                {\n                  var keyValue = convertAttributeValue(attr.node.value);\n\n                  if (keyValue === null) {\n                    throw attr.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n                  }\n\n                  extracted[_name2] = keyValue;\n                  break;\n                }\n\n              default:\n                attribsArray.push(attr);\n            }\n          } else {\n            attribsArray.push(attr);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var children = _core.types.react.buildChildren(path.node);\n\n      var attribs;\n\n      if (attribsArray.length || children.length) {\n        attribs = buildJSXOpeningElementAttributes(attribsArray, file, children);\n      } else {\n        attribs = _core.types.objectExpression([]);\n      }\n\n      args.push(attribs);\n\n      if (development) {\n        var _extracted$key, _extracted$__source, _extracted$__self;\n\n        args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : path.scope.buildUndefinedNode());\n      } else if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildJSXOpeningElementAttributes(attribs, file, children) {\n      var props = attribs.reduce(accumulateAttribute, []);\n\n      if ((children == null ? void 0 : children.length) > 0) {\n        props.push(buildChildrenProperty(children));\n      }\n\n      return _core.types.objectExpression(props);\n    }\n\n    function buildJSXFragmentCall(path, file) {\n      var args = [get(file, \"id/fragment\")()];\n\n      var children = _core.types.react.buildChildren(path.node);\n\n      args.push(_core.types.objectExpression(children.length > 0 ? [buildChildrenProperty(children)] : []));\n\n      if (development) {\n        args.push(path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1));\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildCreateElementFragmentCall(path, file) {\n      if (filter && !filter(path.node, file)) return;\n      return call(file, \"createElement\", [get(file, \"id/fragment\")(), _core.types.nullLiteral()].concat(_toConsumableArray(_core.types.react.buildChildren(path.node))));\n    }\n\n    function buildCreateElementCall(path, file) {\n      var openingPath = path.get(\"openingElement\");\n      return call(file, \"createElement\", [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.get(\"attributes\"))].concat(_toConsumableArray(_core.types.react.buildChildren(path.node))));\n    }\n\n    function getTag(openingPath) {\n      var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n      var tagName;\n\n      if (_core.types.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (_core.types.isLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      if (_core.types.react.isCompatTag(tagName)) {\n        return _core.types.stringLiteral(tagName);\n      } else {\n        return tagExpr;\n      }\n    }\n\n    function buildCreateElementOpeningElementAttributes(file, path, attribs) {\n      var runtime = get(file, \"runtime\");\n      {\n        if (runtime !== \"automatic\") {\n          var objs = [];\n\n          var _props = attribs.reduce(accumulateAttribute, []);\n\n          if (!useSpread) {\n            var start = 0;\n\n            _props.forEach(function (prop, i) {\n              if (_core.types.isSpreadElement(prop)) {\n                if (i > start) {\n                  objs.push(_core.types.objectExpression(_props.slice(start, i)));\n                }\n\n                objs.push(prop.argument);\n                start = i + 1;\n              }\n            });\n\n            if (_props.length > start) {\n              objs.push(_core.types.objectExpression(_props.slice(start)));\n            }\n          } else if (_props.length) {\n            objs.push(_core.types.objectExpression(_props));\n          }\n\n          if (!objs.length) {\n            return _core.types.nullLiteral();\n          }\n\n          if (objs.length === 1) {\n            return objs[0];\n          }\n\n          if (!_core.types.isObjectExpression(objs[0])) {\n            objs.unshift(_core.types.objectExpression([]));\n          }\n\n          var helper = useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n          return _core.types.callExpression(helper, objs);\n        }\n      }\n      var props = [];\n      var found = Object.create(null);\n\n      var _iterator4 = _createForOfIteratorHelper(attribs),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var attr = _step4.value;\n\n          var _name3 = _core.types.isJSXAttribute(attr) && _core.types.isJSXIdentifier(attr.name) && attr.name.name;\n\n          if (runtime === \"automatic\" && (_name3 === \"__source\" || _name3 === \"__self\")) {\n            if (found[_name3]) throw sourceSelfError(path, _name3);\n            found[_name3] = true;\n          }\n\n          accumulateAttribute(props, attr);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return props.length === 1 && _core.types.isSpreadElement(props[0]) ? props[0].argument : props.length > 0 ? _core.types.objectExpression(props) : _core.types.nullLiteral();\n    }\n  });\n\n  function getSource(source, importName) {\n    switch (importName) {\n      case \"Fragment\":\n        return \"\".concat(source, \"/\").concat(development ? \"jsx-dev-runtime\" : \"jsx-runtime\");\n\n      case \"jsxDEV\":\n        return \"\".concat(source, \"/jsx-dev-runtime\");\n\n      case \"jsx\":\n      case \"jsxs\":\n        return \"\".concat(source, \"/jsx-runtime\");\n\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function createImportLazily(pass, path, importName, source) {\n    return function () {\n      var actualSource = getSource(source, importName);\n\n      if ((0, _helperModuleImports.isModule)(path)) {\n        var reference = get(pass, \"imports/\".concat(importName));\n        if (reference) return _core.types.cloneNode(reference);\n        reference = (0, _helperModuleImports.addNamed)(path, importName, actualSource, {\n          importedInterop: \"uncompiled\",\n          importPosition: \"after\"\n        });\n        set(pass, \"imports/\".concat(importName), reference);\n        return reference;\n      } else {\n        var _reference = get(pass, \"requires/\".concat(actualSource));\n\n        if (_reference) {\n          _reference = _core.types.cloneNode(_reference);\n        } else {\n          _reference = (0, _helperModuleImports.addNamespace)(path, actualSource, {\n            importedInterop: \"uncompiled\"\n          });\n          set(pass, \"requires/\".concat(actualSource), _reference);\n        }\n\n        return _core.types.memberExpression(_reference, _core.types.identifier(importName));\n      }\n    };\n  }\n}\n\nfunction toMemberExpression(id) {\n  return id.split(\".\").map(function (name) {\n    return _core.types.identifier(name);\n  }).reduce(function (object, property) {\n    return _core.types.memberExpression(object, property);\n  });\n}\n\nfunction makeSource(path, state) {\n  var location = path.node.loc;\n\n  if (!location) {\n    return path.scope.buildUndefinedNode();\n  }\n\n  if (!state.fileNameIdentifier) {\n    var _state$filename = state.filename,\n        filename = _state$filename === void 0 ? \"\" : _state$filename;\n    var fileNameIdentifier = path.scope.generateUidIdentifier(\"_jsxFileName\");\n    var scope = path.hub.getScope();\n\n    if (scope) {\n      scope.push({\n        id: fileNameIdentifier,\n        init: _core.types.stringLiteral(filename)\n      });\n    }\n\n    state.fileNameIdentifier = fileNameIdentifier;\n  }\n\n  return makeTrace(_core.types.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);\n}\n\nfunction makeTrace(fileNameIdentifier, lineNumber, column0Based) {\n  var fileLineLiteral = lineNumber != null ? _core.types.numericLiteral(lineNumber) : _core.types.nullLiteral();\n  var fileColumnLiteral = column0Based != null ? _core.types.numericLiteral(column0Based + 1) : _core.types.nullLiteral();\n\n  var fileNameProperty = _core.types.objectProperty(_core.types.identifier(\"fileName\"), fileNameIdentifier);\n\n  var lineNumberProperty = _core.types.objectProperty(_core.types.identifier(\"lineNumber\"), fileLineLiteral);\n\n  var columnNumberProperty = _core.types.objectProperty(_core.types.identifier(\"columnNumber\"), fileColumnLiteral);\n\n  return _core.types.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);\n}\n\nfunction sourceSelfError(path, name) {\n  var pluginName = \"transform-react-jsx-\".concat(name.slice(2));\n  return path.buildCodeFrameError(\"Duplicate \".concat(name, \" prop found. You are most likely using the deprecated \").concat(pluginName, \" Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.\"));\n}","map":null,"metadata":{},"sourceType":"script"}