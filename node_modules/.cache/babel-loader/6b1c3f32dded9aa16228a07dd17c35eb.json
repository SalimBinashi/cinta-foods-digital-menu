{"ast":null,"code":"\"use strict\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar diff = require(\"diff\");\n\nvar normalizeOptions = require(\"./options\").normalize;\n\nvar massageAST = require(\"./massage-ast\");\n\nvar comments = require(\"./comments\");\n\nvar parser = require(\"./parser\");\n\nvar printAstToDoc = require(\"./ast-to-doc\");\n\nvar _require = require(\"../common/end-of-line\"),\n    guessEndOfLine = _require.guessEndOfLine,\n    convertEndOfLineToChars = _require.convertEndOfLineToChars;\n\nvar rangeUtil = require(\"./range-util\");\n\nvar privateUtil = require(\"../common/util\");\n\nvar _require2 = require(\"../doc\"),\n    mapDoc = _require2.utils.mapDoc,\n    _printDocToString = _require2.printer.printDocToString,\n    printDocToDebug = _require2.debug.printDocToDebug;\n\nvar UTF8BOM = 0xfeff;\nvar CURSOR = Symbol(\"cursor\");\nvar PLACEHOLDERS = {\n  cursorOffset: \"<<<PRETTIER_CURSOR>>>\",\n  rangeStart: \"<<<PRETTIER_RANGE_START>>>\",\n  rangeEnd: \"<<<PRETTIER_RANGE_END>>>\"\n};\n\nfunction ensureAllCommentsPrinted(astComments) {\n  if (!astComments) {\n    return;\n  }\n\n  for (var i = 0; i < astComments.length; ++i) {\n    if (astComments[i].value.trim() === \"prettier-ignore\") {\n      // If there's a prettier-ignore, we're not printing that sub-tree so we\n      // don't know if the comments was printed or not.\n      return;\n    }\n  }\n\n  astComments.forEach(function (comment) {\n    if (!comment.printed) {\n      throw new Error('Comment \"' + comment.value.trim() + '\" was not printed. Please report this error!');\n    }\n\n    delete comment.printed;\n  });\n}\n\nfunction attachComments(text, ast, opts) {\n  var astComments = ast.comments;\n\n  if (astComments) {\n    delete ast.comments;\n    comments.attach(astComments, ast, text, opts);\n  }\n\n  ast.tokens = [];\n  opts.originalText = opts.parser === \"yaml\" ? text : text.trimRight();\n  return astComments;\n}\n\nfunction coreFormat(text, opts, addAlignmentSize) {\n  if (!text || !text.trim().length) {\n    return {\n      formatted: \"\",\n      cursorOffset: 0\n    };\n  }\n\n  addAlignmentSize = addAlignmentSize || 0;\n  var parsed = parser.parse(text, opts);\n  var ast = parsed.ast;\n  text = parsed.text;\n\n  if (opts.cursorOffset >= 0) {\n    var nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);\n\n    if (nodeResult && nodeResult.node) {\n      opts.cursorNode = nodeResult.node;\n    }\n  }\n\n  var astComments = attachComments(text, ast, opts);\n  var doc = printAstToDoc(ast, opts, addAlignmentSize);\n  var eol = convertEndOfLineToChars(opts.endOfLine);\n\n  var result = _printDocToString(opts.endOfLine === \"lf\" ? doc : mapDoc(doc, function (currentDoc) {\n    return typeof currentDoc === \"string\" && currentDoc.indexOf(\"\\n\") !== -1 ? currentDoc.replace(/\\n/g, eol) : currentDoc;\n  }), opts);\n\n  ensureAllCommentsPrinted(astComments); // Remove extra leading indentation as well as the added indentation after last newline\n\n  if (addAlignmentSize > 0) {\n    var trimmed = result.formatted.trim();\n\n    if (result.cursorNodeStart !== undefined) {\n      result.cursorNodeStart -= result.formatted.indexOf(trimmed);\n    }\n\n    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);\n  }\n\n  if (opts.cursorOffset >= 0) {\n    var oldCursorNodeStart;\n    var oldCursorNodeText;\n    var cursorOffsetRelativeToOldCursorNode;\n    var newCursorNodeStart;\n    var newCursorNodeText;\n\n    if (opts.cursorNode && result.cursorNodeText) {\n      oldCursorNodeStart = opts.locStart(opts.cursorNode);\n      oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode));\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart;\n      newCursorNodeStart = result.cursorNodeStart;\n      newCursorNodeText = result.cursorNodeText;\n    } else {\n      oldCursorNodeStart = 0;\n      oldCursorNodeText = text;\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;\n      newCursorNodeStart = 0;\n      newCursorNodeText = result.formatted;\n    }\n\n    if (oldCursorNodeText === newCursorNodeText) {\n      return {\n        formatted: result.formatted,\n        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode\n      };\n    } // diff old and new cursor node texts, with a special cursor\n    // symbol inserted to find out where it moves to\n\n\n    var oldCursorNodeCharArray = oldCursorNodeText.split(\"\");\n    oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);\n    var newCursorNodeCharArray = newCursorNodeText.split(\"\");\n    var cursorNodeDiff = diff.diffArrays(oldCursorNodeCharArray, newCursorNodeCharArray);\n    var cursorOffset = newCursorNodeStart;\n\n    var _iterator = _createForOfIteratorHelper(cursorNodeDiff),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var entry = _step.value;\n\n        if (entry.removed) {\n          if (entry.value.indexOf(CURSOR) > -1) {\n            break;\n          }\n        } else {\n          cursorOffset += entry.count;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return {\n      formatted: result.formatted,\n      cursorOffset: cursorOffset\n    };\n  }\n\n  return {\n    formatted: result.formatted\n  };\n}\n\nfunction formatRange(text, opts) {\n  var parsed = parser.parse(text, opts);\n  var ast = parsed.ast;\n  text = parsed.text;\n  var range = rangeUtil.calculateRange(text, opts, ast);\n  var rangeStart = range.rangeStart;\n  var rangeEnd = range.rangeEnd;\n  var rangeString = text.slice(rangeStart, rangeEnd); // Try to extend the range backwards to the beginning of the line.\n  // This is so we can detect indentation correctly and restore it.\n  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0\n\n  var rangeStart2 = Math.min(rangeStart, text.lastIndexOf(\"\\n\", rangeStart) + 1);\n  var indentString = text.slice(rangeStart2, rangeStart);\n  var alignmentSize = privateUtil.getAlignmentSize(indentString, opts.tabWidth);\n  var rangeResult = coreFormat(rangeString, Object.assign({}, opts, {\n    rangeStart: 0,\n    rangeEnd: Infinity,\n    // track the cursor offset only if it's within our range\n    cursorOffset: opts.cursorOffset >= rangeStart && opts.cursorOffset < rangeEnd ? opts.cursorOffset - rangeStart : -1\n  }), alignmentSize); // Since the range contracts to avoid trailing whitespace,\n  // we need to remove the newline that was inserted by the `format` call.\n\n  var rangeTrimmed = rangeResult.formatted.trimRight();\n  var rangeLeft = text.slice(0, rangeStart);\n  var rangeRight = text.slice(rangeEnd);\n  var cursorOffset = opts.cursorOffset;\n\n  if (opts.cursorOffset >= rangeEnd) {\n    // handle the case where the cursor was past the end of the range\n    cursorOffset = opts.cursorOffset - rangeEnd + (rangeStart + rangeTrimmed.length);\n  } else if (rangeResult.cursorOffset !== undefined) {\n    // handle the case where the cursor was in the range\n    cursorOffset = rangeResult.cursorOffset + rangeStart;\n  } // keep the cursor as it was if it was before the start of the range\n\n\n  var formatted;\n\n  if (opts.endOfLine === \"lf\") {\n    formatted = rangeLeft + rangeTrimmed + rangeRight;\n  } else {\n    var eol = convertEndOfLineToChars(opts.endOfLine);\n\n    if (cursorOffset >= 0) {\n      var parts = [rangeLeft, rangeTrimmed, rangeRight];\n      var partIndex = 0;\n      var partOffset = cursorOffset;\n\n      while (partIndex < parts.length) {\n        var part = parts[partIndex];\n\n        if (partOffset < part.length) {\n          parts[partIndex] = parts[partIndex].slice(0, partOffset) + PLACEHOLDERS.cursorOffset + parts[partIndex].slice(partOffset);\n          break;\n        }\n\n        partIndex++;\n        partOffset -= part.length;\n      }\n\n      var newRangeLeft = parts[0],\n          newRangeTrimmed = parts[1],\n          newRangeRight = parts[2];\n      formatted = (newRangeLeft.replace(/\\n/g, eol) + newRangeTrimmed + newRangeRight.replace(/\\n/g, eol)).replace(PLACEHOLDERS.cursorOffset, function (_, index) {\n        cursorOffset = index;\n        return \"\";\n      });\n    } else {\n      formatted = rangeLeft.replace(/\\n/g, eol) + rangeTrimmed + rangeRight.replace(/\\n/g, eol);\n    }\n  }\n\n  return {\n    formatted: formatted,\n    cursorOffset: cursorOffset\n  };\n}\n\nfunction format(text, opts) {\n  var selectedParser = parser.resolveParser(opts);\n  var hasPragma = !selectedParser.hasPragma || selectedParser.hasPragma(text);\n\n  if (opts.requirePragma && !hasPragma) {\n    return {\n      formatted: text\n    };\n  }\n\n  if (opts.endOfLine === \"auto\") {\n    opts.endOfLine = guessEndOfLine(text);\n  }\n\n  var hasCursor = opts.cursorOffset >= 0;\n  var hasRangeStart = opts.rangeStart > 0;\n  var hasRangeEnd = opts.rangeEnd < text.length; // get rid of CR/CRLF parsing\n\n  if (text.indexOf(\"\\r\") !== -1) {\n    var offsetKeys = [hasCursor && \"cursorOffset\", hasRangeStart && \"rangeStart\", hasRangeEnd && \"rangeEnd\"].filter(Boolean).sort(function (aKey, bKey) {\n      return opts[aKey] - opts[bKey];\n    });\n\n    for (var i = offsetKeys.length - 1; i >= 0; i--) {\n      var key = offsetKeys[i];\n      text = text.slice(0, opts[key]) + PLACEHOLDERS[key] + text.slice(opts[key]);\n    }\n\n    text = text.replace(/\\r\\n?/g, \"\\n\");\n\n    var _loop = function _loop(_i) {\n      var key = offsetKeys[_i];\n      text = text.replace(PLACEHOLDERS[key], function (_, index) {\n        opts[key] = index;\n        return \"\";\n      });\n    };\n\n    for (var _i = 0; _i < offsetKeys.length; _i++) {\n      _loop(_i);\n    }\n  }\n\n  var hasUnicodeBOM = text.charCodeAt(0) === UTF8BOM;\n\n  if (hasUnicodeBOM) {\n    text = text.substring(1);\n\n    if (hasCursor) {\n      opts.cursorOffset++;\n    }\n\n    if (hasRangeStart) {\n      opts.rangeStart++;\n    }\n\n    if (hasRangeEnd) {\n      opts.rangeEnd++;\n    }\n  }\n\n  if (!hasCursor) {\n    opts.cursorOffset = -1;\n  }\n\n  if (opts.rangeStart < 0) {\n    opts.rangeStart = 0;\n  }\n\n  if (opts.rangeEnd > text.length) {\n    opts.rangeEnd = text.length;\n  }\n\n  var result = hasRangeStart || hasRangeEnd ? formatRange(text, opts) : coreFormat(opts.insertPragma && opts.printer.insertPragma && !hasPragma ? opts.printer.insertPragma(text) : text, opts);\n\n  if (hasUnicodeBOM) {\n    result.formatted = String.fromCharCode(UTF8BOM) + result.formatted;\n\n    if (hasCursor) {\n      result.cursorOffset++;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  formatWithCursor: function formatWithCursor(text, opts) {\n    opts = normalizeOptions(opts);\n    return format(text, opts);\n  },\n  parse: function parse(text, opts, massage) {\n    opts = normalizeOptions(opts);\n\n    if (text.indexOf(\"\\r\") !== -1) {\n      text = text.replace(/\\r\\n?/g, \"\\n\");\n    }\n\n    var parsed = parser.parse(text, opts);\n\n    if (massage) {\n      parsed.ast = massageAST(parsed.ast, opts);\n    }\n\n    return parsed;\n  },\n  formatAST: function formatAST(ast, opts) {\n    opts = normalizeOptions(opts);\n    var doc = printAstToDoc(ast, opts);\n    return _printDocToString(doc, opts);\n  },\n  // Doesn't handle shebang for now\n  formatDoc: function formatDoc(doc, opts) {\n    var debug = printDocToDebug(doc);\n    opts = normalizeOptions(Object.assign({}, opts, {\n      parser: \"babel\"\n    }));\n    return format(debug, opts).formatted;\n  },\n  printToDoc: function printToDoc(text, opts) {\n    opts = normalizeOptions(opts);\n    var parsed = parser.parse(text, opts);\n    var ast = parsed.ast;\n    text = parsed.text;\n    attachComments(text, ast, opts);\n    return printAstToDoc(ast, opts);\n  },\n  printDocToString: function printDocToString(doc, opts) {\n    return _printDocToString(doc, normalizeOptions(opts));\n  }\n};","map":null,"metadata":{},"sourceType":"script"}