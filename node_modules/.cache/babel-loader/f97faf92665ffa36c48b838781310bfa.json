{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/belbet/Project files/cinta-foods-digital-menu/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(genTrue),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(getCachedValue),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(getCachedValueOrWait);\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeWeakCache = makeWeakCache;\nexports.makeWeakCacheSync = makeWeakCacheSync;\nexports.makeStrongCache = makeStrongCache;\nexports.makeStrongCacheSync = makeStrongCacheSync;\nexports.assertSimpleType = assertSimpleType;\n\nfunction _gensync() {\n  var data = require(\"gensync\");\n\n  _gensync = function _gensync() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nvar synchronize = function synchronize(gen) {\n  return _gensync()(gen).sync;\n};\n\nfunction genTrue() {\n  return _regeneratorRuntime.wrap(function genTrue$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", true);\n\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(WeakMap, handler);\n}\n\nfunction makeWeakCacheSync(handler) {\n  return synchronize(makeWeakCache(handler));\n}\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(Map, handler);\n}\n\nfunction makeStrongCacheSync(handler) {\n  return synchronize(makeStrongCache(handler));\n}\n\nfunction makeCachedFunction(CallCache, handler) {\n  var callCacheSync = new CallCache();\n  var callCacheAsync = new CallCache();\n  var futureCache = new CallCache();\n  return /*#__PURE__*/_regeneratorRuntime.mark(function cachedFunction(arg, data) {\n    var asyncContext, callCache, cached, cache, handlerResult, finishLock, value, gen;\n    return _regeneratorRuntime.wrap(function cachedFunction$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.delegateYield((0, _async.isAsync)(), \"t0\", 1);\n\n          case 1:\n            asyncContext = _context2.t0;\n            callCache = asyncContext ? callCacheAsync : callCacheSync;\n            return _context2.delegateYield(getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data), \"t1\", 4);\n\n          case 4:\n            cached = _context2.t1;\n\n            if (!cached.valid) {\n              _context2.next = 7;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", cached.value);\n\n          case 7:\n            cache = new CacheConfigurator(data);\n            handlerResult = handler(arg, cache);\n\n            if (!(0, _util.isIterableIterator)(handlerResult)) {\n              _context2.next = 15;\n              break;\n            }\n\n            gen = handlerResult;\n            return _context2.delegateYield((0, _async.onFirstPause)(gen, function () {\n              finishLock = setupAsyncLocks(cache, futureCache, arg);\n            }), \"t2\", 12);\n\n          case 12:\n            value = _context2.t2;\n            _context2.next = 16;\n            break;\n\n          case 15:\n            value = handlerResult;\n\n          case 16:\n            updateFunctionCache(callCache, cache, arg, value);\n\n            if (finishLock) {\n              futureCache.delete(arg);\n              finishLock.release(value);\n            }\n\n            return _context2.abrupt(\"return\", value);\n\n          case 19:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, cachedFunction);\n  });\n}\n\nfunction getCachedValue(cache, arg, data) {\n  var cachedValue, _iterator, _step, _step$value, value, valid;\n\n  return _regeneratorRuntime.wrap(function getCachedValue$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          cachedValue = cache.get(arg);\n\n          if (!cachedValue) {\n            _context3.next = 20;\n            break;\n          }\n\n          _iterator = _createForOfIteratorHelper(cachedValue);\n          _context3.prev = 3;\n\n          _iterator.s();\n\n        case 5:\n          if ((_step = _iterator.n()).done) {\n            _context3.next = 12;\n            break;\n          }\n\n          _step$value = _step.value, value = _step$value.value, valid = _step$value.valid;\n          return _context3.delegateYield(valid(data), \"t0\", 8);\n\n        case 8:\n          if (!_context3.t0) {\n            _context3.next = 10;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            valid: true,\n            value: value\n          });\n\n        case 10:\n          _context3.next = 5;\n          break;\n\n        case 12:\n          _context3.next = 17;\n          break;\n\n        case 14:\n          _context3.prev = 14;\n          _context3.t1 = _context3[\"catch\"](3);\n\n          _iterator.e(_context3.t1);\n\n        case 17:\n          _context3.prev = 17;\n\n          _iterator.f();\n\n          return _context3.finish(17);\n\n        case 20:\n          return _context3.abrupt(\"return\", {\n            valid: false,\n            value: null\n          });\n\n        case 21:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked2, null, [[3, 14, 17, 20]]);\n}\n\nfunction getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {\n  var cached, _cached, value;\n\n  return _regeneratorRuntime.wrap(function getCachedValueOrWait$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          return _context4.delegateYield(getCachedValue(callCache, arg, data), \"t0\", 1);\n\n        case 1:\n          cached = _context4.t0;\n\n          if (!cached.valid) {\n            _context4.next = 4;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", cached);\n\n        case 4:\n          if (!asyncContext) {\n            _context4.next = 11;\n            break;\n          }\n\n          return _context4.delegateYield(getCachedValue(futureCache, arg, data), \"t1\", 6);\n\n        case 6:\n          _cached = _context4.t1;\n\n          if (!_cached.valid) {\n            _context4.next = 11;\n            break;\n          }\n\n          return _context4.delegateYield((0, _async.waitFor)(_cached.value.promise), \"t2\", 9);\n\n        case 9:\n          value = _context4.t2;\n          return _context4.abrupt(\"return\", {\n            valid: true,\n            value: value\n          });\n\n        case 11:\n          return _context4.abrupt(\"return\", {\n            valid: false,\n            value: null\n          });\n\n        case 12:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked3);\n}\n\nfunction setupAsyncLocks(config, futureCache, arg) {\n  var finishLock = new Lock();\n  updateFunctionCache(futureCache, config, arg, finishLock);\n  return finishLock;\n}\n\nfunction updateFunctionCache(cache, config, arg, value) {\n  if (!config.configured()) config.forever();\n  var cachedValue = cache.get(arg);\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{\n        value: value,\n        valid: genTrue\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"invalidate\":\n      cachedValue = [{\n        value: value,\n        valid: config.validator()\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({\n          value: value,\n          valid: config.validator()\n        });\n      } else {\n        cachedValue = [{\n          value: value,\n          valid: config.validator()\n        }];\n        cache.set(arg, cachedValue);\n      }\n\n  }\n}\n\nvar CacheConfigurator = /*#__PURE__*/function () {\n  function CacheConfigurator(data) {\n    _classCallCheck(this, CacheConfigurator);\n\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = void 0;\n    this._data = data;\n  }\n\n  _createClass(CacheConfigurator, [{\n    key: \"simple\",\n    value: function simple() {\n      return makeSimpleConfigurator(this);\n    }\n  }, {\n    key: \"mode\",\n    value: function mode() {\n      if (this._never) return \"never\";\n      if (this._forever) return \"forever\";\n      if (this._invalidate) return \"invalidate\";\n      return \"valid\";\n    }\n  }, {\n    key: \"forever\",\n    value: function forever() {\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._never) {\n        throw new Error(\"Caching has already been configured with .never()\");\n      }\n\n      this._forever = true;\n      this._configured = true;\n    }\n  }, {\n    key: \"never\",\n    value: function never() {\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._forever) {\n        throw new Error(\"Caching has already been configured with .forever()\");\n      }\n\n      this._never = true;\n      this._configured = true;\n    }\n  }, {\n    key: \"using\",\n    value: function using(handler) {\n      var _this = this;\n\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._never || this._forever) {\n        throw new Error(\"Caching has already been configured with .never or .forever()\");\n      }\n\n      this._configured = true;\n      var key = handler(this._data);\n      var fn = (0, _async.maybeAsync)(handler, \"You appear to be using an async cache handler, but Babel has been called synchronously\");\n\n      if ((0, _async.isThenable)(key)) {\n        return key.then(function (key) {\n          _this._pairs.push([key, fn]);\n\n          return key;\n        });\n      }\n\n      this._pairs.push([key, fn]);\n\n      return key;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(handler) {\n      this._invalidate = true;\n      return this.using(handler);\n    }\n  }, {\n    key: \"validator\",\n    value: function validator() {\n      var pairs = this._pairs;\n      return /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {\n        var _iterator2, _step2, _step2$value, key, fn;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _iterator2 = _createForOfIteratorHelper(pairs);\n                _context5.prev = 1;\n\n                _iterator2.s();\n\n              case 3:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], fn = _step2$value[1];\n                _context5.t0 = key;\n                return _context5.delegateYield(fn(data), \"t1\", 7);\n\n              case 7:\n                _context5.t2 = _context5.t1;\n\n                if (!(_context5.t0 !== _context5.t2)) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", false);\n\n              case 10:\n                _context5.next = 3;\n                break;\n\n              case 12:\n                _context5.next = 17;\n                break;\n\n              case 14:\n                _context5.prev = 14;\n                _context5.t3 = _context5[\"catch\"](1);\n\n                _iterator2.e(_context5.t3);\n\n              case 17:\n                _context5.prev = 17;\n\n                _iterator2.f();\n\n                return _context5.finish(17);\n\n              case 20:\n                return _context5.abrupt(\"return\", true);\n\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee, null, [[1, 14, 17, 20]]);\n      });\n    }\n  }, {\n    key: \"deactivate\",\n    value: function deactivate() {\n      this._active = false;\n    }\n  }, {\n    key: \"configured\",\n    value: function configured() {\n      return this._configured;\n    }\n  }]);\n\n  return CacheConfigurator;\n}();\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(function () {\n      return assertSimpleType(val());\n    });\n  }\n\n  cacheFn.forever = function () {\n    return cache.forever();\n  };\n\n  cacheFn.never = function () {\n    return cache.never();\n  };\n\n  cacheFn.using = function (cb) {\n    return cache.using(function () {\n      return assertSimpleType(cb());\n    });\n  };\n\n  cacheFn.invalidate = function (cb) {\n    return cache.invalidate(function () {\n      return assertSimpleType(cb());\n    });\n  };\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if ((0, _async.isThenable)(value)) {\n    throw new Error(\"You appear to be using an async cache handler, \" + \"which your current version of Babel does not support. \" + \"We may add support for this in the future, \" + \"but if you're on the most recent version of @babel/core and still \" + \"seeing this error, then you'll need to synchronously handle your caching logic.\");\n  }\n\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}\n\nvar Lock = /*#__PURE__*/function () {\n  function Lock() {\n    var _this2 = this;\n\n    _classCallCheck(this, Lock);\n\n    this.released = false;\n    this.promise = void 0;\n    this._resolve = void 0;\n    this.promise = new Promise(function (resolve) {\n      _this2._resolve = resolve;\n    });\n  }\n\n  _createClass(Lock, [{\n    key: \"release\",\n    value: function release(value) {\n      this.released = true;\n\n      this._resolve(value);\n    }\n  }]);\n\n  return Lock;\n}();","map":null,"metadata":{},"sourceType":"script"}