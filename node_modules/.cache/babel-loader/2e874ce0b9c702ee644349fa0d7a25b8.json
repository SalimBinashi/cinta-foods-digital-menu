{"ast":null,"code":"\"use strict\";\n\nvar privateUtil = require(\"../common/util\");\n\nvar sharedUtil = require(\"../common/util-shared\");\n\nvar addLeadingComment = sharedUtil.addLeadingComment,\n    addTrailingComment = sharedUtil.addTrailingComment,\n    addDanglingComment = sharedUtil.addDanglingComment;\n\nfunction handleOwnLineComment(comment, text, options, ast, isLastComment) {\n  var precedingNode = comment.precedingNode,\n      enclosingNode = comment.enclosingNode,\n      followingNode = comment.followingNode;\n\n  if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleMemberExpressionComments(enclosingNode, followingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleImportSpecifierComments(enclosingNode, comment) || handleForComments(enclosingNode, precedingNode, comment) || handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) || handleAssignmentPatternComments(enclosingNode, comment) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleEndOfLineComment(comment, text, options, ast, isLastComment) {\n  var precedingNode = comment.precedingNode,\n      enclosingNode = comment.enclosingNode,\n      followingNode = comment.followingNode;\n\n  if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) || handleImportSpecifierComments(enclosingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleLabeledStatementComments(enclosingNode, comment) || handleCallExpressionComments(precedingNode, enclosingNode, comment) || handlePropertyComments(enclosingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleTypeAliasComments(enclosingNode, followingNode, comment) || handleVariableDeclaratorComments(enclosingNode, followingNode, comment)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleRemainingComment(comment, text, options, ast, isLastComment) {\n  var precedingNode = comment.precedingNode,\n      enclosingNode = comment.enclosingNode,\n      followingNode = comment.followingNode;\n\n  if (handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) || handleCommentInEmptyParens(text, enclosingNode, comment, options) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleCommentAfterArrowParams(text, enclosingNode, comment, options) || handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) || handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) || handleBreakAndContinueStatementComments(enclosingNode, comment)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction addBlockStatementFirstComment(node, comment) {\n  var body = node.body.filter(function (n) {\n    return n.type !== \"EmptyStatement\";\n  });\n\n  if (body.length === 0) {\n    addDanglingComment(node, comment);\n  } else {\n    addLeadingComment(body[0], comment);\n  }\n}\n\nfunction addBlockOrNotComment(node, comment) {\n  if (node.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(node, comment);\n  } else {\n    addLeadingComment(node, comment);\n  }\n} // There are often comments before the else clause of if statements like\n//\n//   if (1) { ... }\n//   // comment\n//   else { ... }\n//\n// They are being attached as leading comments of the BlockExpression which\n// is not well printed. What we want is to instead move the comment inside\n// of the block and make it leadingComment of the first element of the block\n// or dangling comment of the block if there is nothing inside\n//\n//   if (1) { ... }\n//   else {\n//     // comment\n//     ...\n//   }\n\n\nfunction handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n  if (!enclosingNode || enclosingNode.type !== \"IfStatement\" || !followingNode) {\n    return false;\n  } // We unfortunately have no way using the AST or location of nodes to know\n  // if the comment is positioned before the condition parenthesis:\n  //   if (a /* comment */) {}\n  // The only workaround I found is to look at the next character to see if\n  // it is a ).\n\n\n  var nextCharacter = privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);\n\n  if (nextCharacter === \")\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  } // Comments before `else`:\n  // - treat as trailing comments of the consequent, if it's a BlockStatement\n  // - treat as a dangling comment otherwise\n\n\n  if (precedingNode === enclosingNode.consequent && followingNode === enclosingNode.alternate) {\n    if (precedingNode.type === \"BlockStatement\") {\n      addTrailingComment(precedingNode, comment);\n    } else {\n      addDanglingComment(enclosingNode, comment);\n    }\n\n    return true;\n  }\n\n  if (followingNode.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(followingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"IfStatement\") {\n    addBlockOrNotComment(followingNode.consequent, comment);\n    return true;\n  } // For comments positioned after the condition parenthesis in an if statement\n  // before the consequent without brackets on, such as\n  // if (a) /* comment */ true,\n  // we look at the next character to see if the following node\n  // is the consequent for the if statement\n\n\n  if (enclosingNode.consequent === followingNode) {\n    addLeadingComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n  if (!enclosingNode || enclosingNode.type !== \"WhileStatement\" || !followingNode) {\n    return false;\n  } // We unfortunately have no way using the AST or location of nodes to know\n  // if the comment is positioned before the condition parenthesis:\n  //   while (a /* comment */) {}\n  // The only workaround I found is to look at the next character to see if\n  // it is a ).\n\n\n  var nextCharacter = privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);\n\n  if (nextCharacter === \")\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n} // Same as IfStatement but for TryStatement\n\n\nfunction handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) {\n  if (!enclosingNode || enclosingNode.type !== \"TryStatement\" && enclosingNode.type !== \"CatchClause\" || !followingNode) {\n    return false;\n  }\n\n  if (enclosingNode.type === \"CatchClause\" && precedingNode) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"BlockStatement\") {\n    addBlockStatementFirstComment(followingNode, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"TryStatement\") {\n    addBlockOrNotComment(followingNode.finalizer, comment);\n    return true;\n  }\n\n  if (followingNode.type === \"CatchClause\") {\n    addBlockOrNotComment(followingNode.body, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleMemberExpressionComments(enclosingNode, followingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"MemberExpression\" && followingNode && followingNode.type === \"Identifier\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) {\n  var isSameLineAsPrecedingNode = precedingNode && !privateUtil.hasNewlineInRange(text, options.locEnd(precedingNode), options.locStart(comment));\n\n  if ((!precedingNode || !isSameLineAsPrecedingNode) && enclosingNode && enclosingNode.type === \"ConditionalExpression\" && followingNode) {\n    addLeadingComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ObjectProperty\" || enclosingNode.type === \"Property\") && enclosingNode.shorthand && enclosingNode.key === precedingNode && enclosingNode.value.type === \"AssignmentPattern\") {\n    addTrailingComment(enclosingNode.value.left, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleClassComments(enclosingNode, precedingNode, followingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ClassDeclaration\" || enclosingNode.type === \"ClassExpression\") && enclosingNode.decorators && enclosingNode.decorators.length > 0 && !(followingNode && followingNode.type === \"Decorator\")) {\n    if (!enclosingNode.decorators || enclosingNode.decorators.length === 0) {\n      addLeadingComment(enclosingNode, comment);\n    } else {\n      addTrailingComment(enclosingNode.decorators[enclosingNode.decorators.length - 1], comment);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) {\n  // This is only needed for estree parsers (flow, typescript) to attach\n  // after a method name:\n  // obj = { fn /*comment*/() {} };\n  if (enclosingNode && precedingNode && (enclosingNode.type === \"Property\" || enclosingNode.type === \"MethodDefinition\") && precedingNode.type === \"Identifier\" && enclosingNode.key === precedingNode && // special Property case: { key: /*comment*/(value) };\n  // comment should be attached to value instead of key\n  privateUtil.getNextNonSpaceNonCommentCharacter(text, precedingNode, options.locEnd) !== \":\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  } // Print comments between decorators and class methods as a trailing comment\n  // on the decorator node instead of the method node\n\n\n  if (precedingNode && enclosingNode && precedingNode.type === \"Decorator\" && (enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"ClassProperty\" || enclosingNode.type === \"TSAbstractClassProperty\" || enclosingNode.type === \"TSAbstractMethodDefinition\" || enclosingNode.type === \"MethodDefinition\")) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) {\n  if (privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== \"(\") {\n    return false;\n  }\n\n  if (precedingNode && enclosingNode && (enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"MethodDefinition\" || enclosingNode.type === \"ObjectMethod\")) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleCommentAfterArrowParams(text, enclosingNode, comment, options) {\n  if (!(enclosingNode && enclosingNode.type === \"ArrowFunctionExpression\")) {\n    return false;\n  }\n\n  var index = sharedUtil.getNextNonSpaceNonCommentCharacterIndex(text, comment, options);\n\n  if (text.substr(index, 2) === \"=>\") {\n    addDanglingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleCommentInEmptyParens(text, enclosingNode, comment, options) {\n  if (privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== \")\") {\n    return false;\n  } // Only add dangling comments to fix the case when no params are present,\n  // i.e. a function without any argument.\n\n\n  if (enclosingNode && ((enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"ArrowFunctionExpression\" || enclosingNode.type === \"ClassMethod\" || enclosingNode.type === \"ObjectMethod\") && enclosingNode.params.length === 0 || (enclosingNode.type === \"CallExpression\" || enclosingNode.type === \"NewExpression\") && enclosingNode.arguments.length === 0)) {\n    addDanglingComment(enclosingNode, comment);\n    return true;\n  }\n\n  if (enclosingNode && enclosingNode.type === \"MethodDefinition\" && enclosingNode.value.params.length === 0) {\n    addDanglingComment(enclosingNode.value, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) {\n  // Type definitions functions\n  if (precedingNode && precedingNode.type === \"FunctionTypeParam\" && enclosingNode && enclosingNode.type === \"FunctionTypeAnnotation\" && followingNode && followingNode.type !== \"FunctionTypeParam\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  } // Real functions\n\n\n  if (precedingNode && (precedingNode.type === \"Identifier\" || precedingNode.type === \"AssignmentPattern\") && enclosingNode && (enclosingNode.type === \"ArrowFunctionExpression\" || enclosingNode.type === \"FunctionExpression\" || enclosingNode.type === \"FunctionDeclaration\" || enclosingNode.type === \"ObjectMethod\" || enclosingNode.type === \"ClassMethod\") && privateUtil.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) === \")\") {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  if (enclosingNode && enclosingNode.type === \"FunctionDeclaration\" && followingNode && followingNode.type === \"BlockStatement\") {\n    var functionParamRightParenIndex = function () {\n      if (enclosingNode.params.length !== 0) {\n        return privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(privateUtil.getLast(enclosingNode.params)));\n      }\n\n      var functionParamLeftParenIndex = privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(enclosingNode.id));\n      return privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, functionParamLeftParenIndex + 1);\n    }();\n\n    if (options.locStart(comment) > functionParamRightParenIndex) {\n      addBlockStatementFirstComment(followingNode, comment);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction handleImportSpecifierComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"ImportSpecifier\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleLabeledStatementComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"LabeledStatement\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleBreakAndContinueStatementComments(enclosingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ContinueStatement\" || enclosingNode.type === \"BreakStatement\") && !enclosingNode.label) {\n    addTrailingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleCallExpressionComments(precedingNode, enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"CallExpression\" && precedingNode && enclosingNode.callee === precedingNode && enclosingNode.arguments.length > 0) {\n    addLeadingComment(enclosingNode.arguments[0], comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"UnionTypeAnnotation\" || enclosingNode.type === \"TSUnionType\")) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handlePropertyComments(enclosingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"Property\" || enclosingNode.type === \"ObjectProperty\")) {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleOnlyComments(enclosingNode, ast, comment, isLastComment) {\n  // With Flow the enclosingNode is undefined so use the AST instead.\n  if (ast && ast.body && ast.body.length === 0) {\n    if (isLastComment) {\n      addDanglingComment(ast, comment);\n    } else {\n      addLeadingComment(ast, comment);\n    }\n\n    return true;\n  } else if (enclosingNode && enclosingNode.type === \"Program\" && enclosingNode.body.length === 0 && enclosingNode.directives && enclosingNode.directives.length === 0) {\n    if (isLastComment) {\n      addDanglingComment(enclosingNode, comment);\n    } else {\n      addLeadingComment(enclosingNode, comment);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleForComments(enclosingNode, precedingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"ForInStatement\" || enclosingNode.type === \"ForOfStatement\")) {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) {\n  if (precedingNode && precedingNode.type === \"ImportSpecifier\" && enclosingNode && enclosingNode.type === \"ImportDeclaration\" && privateUtil.hasNewline(text, options.locEnd(comment))) {\n    addTrailingComment(precedingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleAssignmentPatternComments(enclosingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"AssignmentPattern\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleTypeAliasComments(enclosingNode, followingNode, comment) {\n  if (enclosingNode && enclosingNode.type === \"TypeAlias\") {\n    addLeadingComment(enclosingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleVariableDeclaratorComments(enclosingNode, followingNode, comment) {\n  if (enclosingNode && (enclosingNode.type === \"VariableDeclarator\" || enclosingNode.type === \"AssignmentExpression\") && followingNode && (followingNode.type === \"ObjectExpression\" || followingNode.type === \"ArrayExpression\" || followingNode.type === \"TemplateLiteral\" || followingNode.type === \"TaggedTemplateExpression\")) {\n    addLeadingComment(followingNode, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) {\n  if (!enclosingNode || enclosingNode.type !== \"TSMappedType\") {\n    return false;\n  }\n\n  if (followingNode && followingNode.type === \"TSTypeParameter\" && followingNode.name) {\n    addLeadingComment(followingNode.name, comment);\n    return true;\n  }\n\n  if (precedingNode && precedingNode.type === \"TSTypeParameter\" && precedingNode.constraint) {\n    addTrailingComment(precedingNode.constraint, comment);\n    return true;\n  }\n\n  return false;\n}\n\nfunction isBlockComment(comment) {\n  return comment.type === \"Block\" || comment.type === \"CommentBlock\";\n}\n\nfunction hasLeadingComment(node) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n    return true;\n  };\n\n  if (node.leadingComments) {\n    return node.leadingComments.some(fn);\n  }\n\n  if (node.comments) {\n    return node.comments.some(function (comment) {\n      return comment.leading && fn(comment);\n    });\n  }\n\n  return false;\n}\n\nmodule.exports = {\n  handleOwnLineComment: handleOwnLineComment,\n  handleEndOfLineComment: handleEndOfLineComment,\n  handleRemainingComment: handleRemainingComment,\n  hasLeadingComment: hasLeadingComment,\n  isBlockComment: isBlockComment\n};","map":null,"metadata":{},"sourceType":"script"}