{"ast":null,"code":"\"use strict\";\n\nfunction assertDoc(val) {\n  /* istanbul ignore if */\n  if (!(typeof val === \"string\" || val != null && typeof val.type === \"string\")) {\n    throw new Error(\"Value \" + JSON.stringify(val) + \" is not a valid document\");\n  }\n}\n\nfunction concat(parts) {\n  if (process.env.NODE_ENV !== \"production\") {\n    parts.forEach(assertDoc);\n  } // We cannot do this until we change `printJSXElement` to not\n  // access the internals of a document directly.\n  // if(parts.length === 1) {\n  //   // If it's a single document, no need to concat it.\n  //   return parts[0];\n  // }\n\n\n  return {\n    type: \"concat\",\n    parts: parts\n  };\n}\n\nfunction indent(contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"indent\",\n    contents: contents\n  };\n}\n\nfunction align(n, contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"align\",\n    contents: contents,\n    n: n\n  };\n}\n\nfunction group(contents, opts) {\n  opts = opts || {};\n\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"group\",\n    id: opts.id,\n    contents: contents,\n    \"break\": !!opts.shouldBreak,\n    expandedStates: opts.expandedStates\n  };\n}\n\nfunction dedentToRoot(contents) {\n  return align(-Infinity, contents);\n}\n\nfunction markAsRoot(contents) {\n  return align({\n    type: \"root\"\n  }, contents);\n}\n\nfunction dedent(contents) {\n  return align(-1, contents);\n}\n\nfunction conditionalGroup(states, opts) {\n  return group(states[0], Object.assign(opts || {}, {\n    expandedStates: states\n  }));\n}\n\nfunction fill(parts) {\n  if (process.env.NODE_ENV !== \"production\") {\n    parts.forEach(assertDoc);\n  }\n\n  return {\n    type: \"fill\",\n    parts: parts\n  };\n}\n\nfunction ifBreak(breakContents, flatContents, opts) {\n  opts = opts || {};\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (breakContents) {\n      assertDoc(breakContents);\n    }\n\n    if (flatContents) {\n      assertDoc(flatContents);\n    }\n  }\n\n  return {\n    type: \"if-break\",\n    breakContents: breakContents,\n    flatContents: flatContents,\n    groupId: opts.groupId\n  };\n}\n\nfunction lineSuffix(contents) {\n  if (process.env.NODE_ENV !== \"production\") {\n    assertDoc(contents);\n  }\n\n  return {\n    type: \"line-suffix\",\n    contents: contents\n  };\n}\n\nvar lineSuffixBoundary = {\n  type: \"line-suffix-boundary\"\n};\nvar breakParent = {\n  type: \"break-parent\"\n};\nvar trim = {\n  type: \"trim\"\n};\nvar line = {\n  type: \"line\"\n};\nvar softline = {\n  type: \"line\",\n  soft: true\n};\nvar hardline = concat([{\n  type: \"line\",\n  hard: true\n}, breakParent]);\nvar literalline = concat([{\n  type: \"line\",\n  hard: true,\n  literal: true\n}, breakParent]);\nvar cursor = {\n  type: \"cursor\",\n  placeholder: Symbol(\"cursor\")\n};\n\nfunction join(sep, arr) {\n  var res = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (i !== 0) {\n      res.push(sep);\n    }\n\n    res.push(arr[i]);\n  }\n\n  return concat(res);\n}\n\nfunction addAlignmentToDoc(doc, size, tabWidth) {\n  var aligned = doc;\n\n  if (size > 0) {\n    // Use indent to add tabs for all the levels of tabs we need\n    for (var i = 0; i < Math.floor(size / tabWidth); ++i) {\n      aligned = indent(aligned);\n    } // Use align for all the spaces that are needed\n\n\n    aligned = align(size % tabWidth, aligned); // size is absolute from 0 and not relative to the current\n    // indentation, so we use -Infinity to reset the indentation to 0\n\n    aligned = align(-Infinity, aligned);\n  }\n\n  return aligned;\n}\n\nmodule.exports = {\n  concat: concat,\n  join: join,\n  line: line,\n  softline: softline,\n  hardline: hardline,\n  literalline: literalline,\n  group: group,\n  conditionalGroup: conditionalGroup,\n  fill: fill,\n  lineSuffix: lineSuffix,\n  lineSuffixBoundary: lineSuffixBoundary,\n  cursor: cursor,\n  breakParent: breakParent,\n  ifBreak: ifBreak,\n  trim: trim,\n  indent: indent,\n  align: align,\n  addAlignmentToDoc: addAlignmentToDoc,\n  markAsRoot: markAsRoot,\n  dedentToRoot: dedentToRoot,\n  dedent: dedent\n};","map":null,"metadata":{},"sourceType":"script"}